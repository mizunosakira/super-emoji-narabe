<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ã‚¹ãƒ¼ãƒ‘ãƒ¼emojiä¸¦ã¹</title>
    <style>
        body {
            background-color: black;
            color: white;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            height: 100vh;
            margin: 0;
            overflow-x: hidden;
        }

        #game-board {
            display: grid;
            grid-template-columns: repeat(3, 100px);
            grid-template-rows: repeat(3, 100px);
            gap: 5px;
            margin: 20px 0;
        }

        .grid-item {
            width: 100px;
            height: 100px;
            background-color: black;
            border: 2px solid white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2em;
            cursor: pointer;
            transition: background-color 0.3s, border-color 0.3s;
        }

        .player {
            border: 5px solid blue;
            box-sizing: border-box;
        }

        .npc {
            border: 5px solid red;
            box-sizing: border-box;
        }

        .sealed {
            color: red;
            font-size: 1.5em;
            border: 2px solid gray;
            /* è¿½åŠ  */
        }

        .hand-container {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            overflow-x: auto;
            padding: 20px 120px 20px 120px;
            width: 100%;
            box-sizing: border-box;
            justify-content: center;
            flex-wrap: nowrap;
        }

        .hand-item {
            font-size: 2em;
            cursor: pointer;
            transition: transform 0.2s;
            flex-shrink: 0;
            flex-basis: calc(100% / 10);
        }

        .hand-item:hover {
            transform: scale(1.2);
        }

        #message,
        #turn-indicator {
            font-size: 1.2em;
            margin-top: 10px;
            text-align: center;
        }

        #restart-button,
        #start-button,
        #forfeit-button,
        #log-button {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 1em;
            background-color: white;
            color: black;
            border: none;
            cursor: pointer;
        }

        #restart-button:hover,
        #start-button:hover,
        #forfeit-button:hover,
        #log-button:hover {
            background-color: lightgray;
        }

        #rule-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            text-align: center;
            color: white;
        }

        #level-select {
            margin-top: 20px;
        }

        #level-select button {
            margin: 5px;
            padding: 10px 20px;
            font-size: 1em;
            background-color: white;
            color: black;
            border: none;
            cursor: pointer;
        }

        #level-select button:hover {
            background-color: lightgray;
        }

        .hand-title {
            font-size: 1em;
            margin: 5px 0;
            text-align: center;
        }

        .hand-title-container {
            display: flex;
            justify-content: center;
            width: 100%;
        }

        #log-container {
            display: none;
            background-color: #222;
            padding: 80px;
            margin-top: 10px;
            width: 90%;
            max-height: 400px;
            overflow-y: auto;
            box-sizing: border-box;
        }

        /* ãƒ†ã‚­ã‚¹ãƒˆãƒ­ã‚°ãƒœã‚¿ãƒ³ã‚’åˆæœŸçŠ¶æ…‹ã§éè¡¨ç¤ºã«è¨­å®š */

        #log-button {
            display: none;
        }

        /* è¿½åŠ ã™ã‚‹ã‚¹ã‚¿ã‚¤ãƒ« */
        @media screen and (max-width: 600px) {
            .hand-container {
                flex-wrap: wrap;
                /* è¤‡æ•°è¡Œã«ã™ã‚‹ */
                justify-content: flex-start;
                /* å·¦å¯„ã›ã«ã™ã‚‹ */
                padding: 10px;
                /* ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã‚’èª¿æ•´ */
            }

            .hand-item {
                flex-basis: calc(100% / 7);
                /* 1è¡Œã«7ã¤è¡¨ç¤ºã™ã‚‹ã‚ˆã†ã«èª¿æ•´ */
            }
        }

    </style>
</head>

<body>
    <div id="rule-container">
        <h1>ã‚¹ãƒ¼ãƒ‘ãƒ¼emojiä¸¦ã¹</h1>
        <p>çµµæ–‡å­—ã‚’ä½¿ã£ãŸï¼‘äººç”¨ã®ä¸‰ç›®ä¸¦ã¹ã‚²ãƒ¼ãƒ ã§ã™ã€‚
            <br> CPUã¨äº¤äº’ã«æ‰‹æœ­ã®ã‚³ãƒã‚’ï¼‘ã¤é¸ã³ã€ç©ºã„ã¦ã„ã‚‹ãƒã‚¹ã«é…ç½®ã—ã¾ã™ã€‚
            <br> è‡ªåˆ†ã®ã‚³ãƒã‚’ç¸¦ãƒ»æ¨ªãƒ»æ–œã‚ã®ã„ãšã‚Œã‹ã«3ã¤ä¸¦ã¹ãŸãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒå‹è€…ã¨ãªã‚Šã¾ã™ã€‚
            <br> ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å´ãŒå…ˆè¡Œã¨ãªã‚Šã¾ã™ã€‚
            <br> å‡ºã›ã‚‹ã‚³ãƒãŒãªã„å ´åˆã¯ç›¸æ‰‹ã®ã‚¿ãƒ¼ãƒ³ã¨ãªã‚Šã¾ã™ã€‚
            <br> ãŠäº’ã„ã«å‡ºã›ã‚‹ã‚³ãƒãŒãªããªã£ãŸå ´åˆã¯å¼•ãåˆ†ã‘ã§ã™ã€‚
        </p>
        <div id="level-select">
            <p>ç›¸æ‰‹ã®ãƒ¬ãƒ™ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„:</p>
            <button onclick="startGame(1)">ãƒ¬ãƒ™ãƒ« 1</button>
            <button onclick="startGame(2)">ãƒ¬ãƒ™ãƒ« 2</button>
            <button onclick="startGame(3)">ãƒ¬ãƒ™ãƒ« 3</button>
            <button onclick="startGame(4)">ãƒ¬ãƒ™ãƒ« 4</button>
            <button onclick="startGame(5)">ãƒ¬ãƒ™ãƒ« 5</button>
        </div>
        <div id="win-streak-score">
            <p><br>é€£å‹æ•°: 0 ã‚¹ã‚³ã‚¢: 0ç‚¹</p>
        </div>
    </div>
    <div id="npc-hand-container" style="display: none;">
        <div class="hand-title-container">
            <div class="hand-title">ç›¸æ‰‹ã®æ‰‹æœ­</div>
        </div>
        <div id="npc-hand" class="hand-container"></div>
    </div>
    <div id="game-board" style="display: none;"></div>
    <div id="player-hand-container" style="display: none;">
        <div class="hand-title-container">
            <div class="hand-title">è‡ªåˆ†ã®æ‰‹æœ­</div>
        </div>
        <div id="player-hand" class="hand-container"></div>
    </div>
    <div id="turn-indicator" style="display: none;">è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³</div>
    <div id="message" style="display: none;"></div>
    <button id="restart-button" onclick="resetGame()" style="display: none;">ã‚‚ã†ä¸€åº¦ãƒ—ãƒ¬ã‚¤ã™ã‚‹</button>
    <button id="forfeit-button" onclick="forfeitGame()" style="display: none;">é™å‚ã™ã‚‹</button>
    <button id="log-button" onclick="toggleLog()">ãƒ†ã‚­ã‚¹ãƒˆãƒ­ã‚°</button>
    <div id="log-container"></div>
    <script>
        let playerTurn = true;
        let gameOver = false;
        const board = Array(9).fill(null);
        let level = 1;
        let logEntries = [];
        let sealedTiles = [];
        let winStreak = 0;
        let score = 0;
        const gameBoard = document.getElementById('game-board');
        const playerHand = document.getElementById('player-hand');
        const npcHand = document.getElementById('npc-hand');
        const message = document.getElementById('message');
        const turnIndicator = document.getElementById('turn-indicator');
        const restartButton = document.getElementById('restart-button');
        const forfeitButton = document.getElementById('forfeit-button');
        const levelSelect = document.getElementById('level-select');
        const logContainer = document.getElementById('log-container');
        const logButton = document.getElementById('log-button');
        const winStreakScore = document.getElementById('win-streak-score');
        const emojis = [{
            emoji: "ğŸ°",
            name: "ã‚¦ã‚µã‚®",
            rank: "â˜…",
            hp: 2,
            effect: "heal_ally",
            maxHp: 2
        }, {
            emoji: "ğŸ·",
            name: "ãƒ–ã‚¿",
            rank: "â˜…",
            hp: 3,
            effect: "none",
            maxHp: 3
        }, {
            emoji: "ğŸ",
            name: "ãƒãƒ",
            rank: "â˜…",
            hp: 1,
            effect: "revengeEffect",
            maxHp: 1
        }, {
            emoji: "ğŸ§™",
            name: "é­”æ³•ä½¿ã„",
            rank: "â˜…",
            hp: 1,
            effect: "damage_random_enemy",
            maxHp: 1
        }, {
            emoji: "ğŸ”«",
            name: "æ‹³éŠƒ",
            rank: "â˜…",
            hp: 1,
            effect: "damage_self_enemy",
            maxHp: 1
        }, {
            emoji: "ğŸµ",
            name: "çŒ¿",
            rank: "â˜…â˜…",
            hp: 1,
            effect: "swap_position",
            maxHp: 1
        }, {
            emoji: "ğŸŠ",
            name: "ãƒ¯ãƒ‹",
            rank: "â˜…",
            hp: 2,
            effect: "damage_column_enemy",
            maxHp: 2
        }, {
            emoji: "ğŸ»",
            name: "ã‚¯ãƒ",
            rank: "â˜…",
            hp: 2,
            effect: "damage_row_enemy",
            maxHp: 2
        }, {
            emoji: "ğŸ™",
            name: "ã‚¿ã‚³",
            rank: "â˜…",
            hp: 2,
            effect: "damage_heal",
            maxHp: 2
        }, {
            emoji: "ğŸ¥·",
            name: "ãƒ‹ãƒ³ã‚¸ãƒ£",
            rank: "â˜…â˜…",
            hp: 2,
            effect: "steal_hand",
            maxHp: 2
        }, {
            emoji: "ğŸ¦„",
            name: "ãƒ¦ãƒ‹ã‚³ãƒ¼ãƒ³",
            rank: "â˜…â˜…",
            hp: 4,
            effect: "heal_all_friends",
            maxHp: 4
        }, {
            emoji: "ğŸ‘¼",
            name: "å¤©ä½¿",
            rank: "â˜…â˜…",
            hp: 4,
            effect: "add_random_hand_both",
            maxHp: 4
        }, {
            emoji: "ğŸ‘®",
            name: "è­¦å®˜",
            rank: "â˜…â˜…",
            hp: 4,
            effect: "add_gun",
            maxHp: 4
        }, {
            emoji: "ğŸ‘º",
            name: "å¤©ç‹—",
            rank: "â˜…â˜…",
            hp: 3,
            effect: "damage_move_enemy",
            maxHp: 3
        }, {
            emoji: "ğŸ§›",
            name: "å¸è¡€é¬¼",
            rank: "â˜…â˜…",
            hp: 2,
            effect: "damage_heal_self",
            maxHp: 2
        }, {
            emoji: "ğŸ’£",
            name: "çˆ†å¼¾",
            rank: "â˜…â˜…",
            hp: 3,
            effect: "explode_on_death",
            maxHp: 3
        }, {
            emoji: "ğŸ¦",
            name: "ãƒ©ã‚¤ã‚ªãƒ³",
            rank: "â˜…â˜…",
            hp: 5,
            effect: "damage_all_around",
            maxHp: 5
        }, {
            emoji: "ğŸ‘¿",
            name: "æ‚ªé­”",
            rank: "â˜…â˜…â˜…",
            hp: 6,
            effect: "seal_random",
            maxHp: 6
        }, {
            emoji: "ğŸ‰",
            name: "ãƒ‰ãƒ©ã‚´ãƒ³",
            rank: "â˜…â˜…â˜…",
            hp: 6,
            effect: "damage_all_seal",
            maxHp: 6
        }, {
            emoji: "ğŸ‘½",
            name: "å®‡å®™äºº",
            rank: "â˜…â˜…â˜…",
            hp: 5,
            effect: "return_enemy_hand",
            maxHp: 5
        }, {
            emoji: "ğŸ‘¹",
            name: "é¬¼",
            rank: "â˜…â˜…â˜…",
            hp: 6,
            effect: "damage_adjacent_all_enemy",
            maxHp: 6
        }];
        let playerEmojis = [];
        let npcEmojis = [];

        function startGame(selectedLevel) {
            level = selectedLevel;
            document.getElementById('rule-container').style.display = 'none';
            document.getElementById('npc-hand-container').style.display = 'block';
            document.getElementById('player-hand-container').style.display = 'block';
            turnIndicator.style.display = 'block';
            gameBoard.style.display = 'grid';
            message.style.display = 'block';
            levelSelect.style.display = 'none';
            forfeitButton.style.display = 'block';
            logButton.style.display = 'block';
            logEntries = [];
            gameOver = false;
            updateLog("ã‚²ãƒ¼ãƒ é–‹å§‹");
            logContainer.innerHTML = '';
            logContainer.style.display = 'none';
            sealedTiles = [];

            // å…¨ã¦ã®ã‚³ãƒã®HPã‚’maxHpã«ãƒªã‚»ãƒƒãƒˆ
            emojis.forEach(emoji => {
                emoji.hp = emoji.maxHp;
            });

            playerEmojis = generateRandomHand();
            setupNPCEmojis();
            renderHand(playerEmojis, playerHand, 'player');
            renderHand(npcEmojis, npcHand, 'npc');
            renderBoard();
            updateTurnIndicator();
        }

        // æ–°ã—ã„ã‚²ãƒ¼ãƒ ã®é–‹å§‹æ™‚ã®ã‚³ãƒã®åˆæœŸåŒ–
        function generateRandomHand() {
            const hand = [];
            while (hand.length < 10) {
                const randomEmoji = deepCopy(emojis[Math.floor(Math.random() * emojis.length)]);
                hand.push(randomEmoji);
            }
            return hand;
        }
        // å ´ã«å‡ºã‚‹éš›ã®ã‚³ãƒã®æ·±ã„ã‚³ãƒ”ãƒ¼ã‚’ä½œæˆã™ã‚‹é–¢æ•°
        function deepCopy(obj) {
            return JSON.parse(JSON.stringify(obj));
        }

        function setupNPCEmojis() {
            const starOne = emojis.filter(emoji => emoji.rank === 'â˜…');
            const starTwo = emojis.filter(emoji => emoji.rank === 'â˜…â˜…');
            const starThree = emojis.filter(emoji => emoji.rank === 'â˜…â˜…â˜…');
            switch (level) {
                case 1:
                    npcEmojis = [...generateRandomHand().slice(0, 8), ...shuffleArray(starTwo.map(e => ({
                        ...e
                    }))).slice(0, 2)];
                    break;
                case 2:
                    npcEmojis = [...generateRandomHand().slice(0, 7), ...shuffleArray(starTwo.map(e => ({
                        ...e
                    }))).slice(0, 2), ...shuffleArray(starThree.map(e => ({
                        ...e
                    }))).slice(0, 1)];
                    break;
                case 3:
                    npcEmojis = [...generateRandomHand().slice(0, 5), ...shuffleArray(starTwo.map(e => ({
                        ...e
                    }))).slice(0, 3), ...shuffleArray(starThree.map(e => ({
                        ...e
                    }))).slice(0, 2)];
                    break;
                case 4:
                    npcEmojis = [...generateRandomHand().slice(0, 3), ...shuffleArray(starTwo.map(e => ({
                        ...e
                    }))).slice(0, 4), ...shuffleArray(starThree.map(e => ({
                        ...e
                    }))).slice(0, 3)];
                    break;
                case 5:
                    // ãƒ¬ãƒ™ãƒ«5ã®æ‰‹æœ­ã‚’â˜…â˜…5æšã€â˜…â˜…â˜…5æšã«è¨­å®šï¼ˆåŒåã®ã‚³ãƒãŒæ¥ã‚‹å¯èƒ½æ€§ã‚ã‚Šï¼‰
                    npcEmojis = [
                        ...Array(5).fill().map(() => ({
                            ...starTwo[Math.floor(Math.random() * starTwo.length)]
                        })),
                        ...Array(5).fill().map(() => ({
                            ...starThree[Math.floor(Math.random() * starThree.length)]
                        }))
                    ];
                    break;
            }
        }

        function renderHand(hand, element, player) {
            element.innerHTML = '';
            hand.forEach((emoji, index) => {
                const handItem = document.createElement('div');
                handItem.className = 'hand-item';
                handItem.textContent = emoji.emoji;
                handItem.onclick = () => selectEmoji(index, player);
                element.appendChild(handItem);
            });
        }

        function renderBoard() {
            gameBoard.innerHTML = '';
            board.forEach((cell, index) => {
                const gridItem = document.createElement('div');
                gridItem.className = 'grid-item';
                gridItem.onclick = () => makeMove(index);
                if (cell) {
                    gridItem.textContent = cell.emoji.emoji;
                    gridItem.style.color = cell.player === 'player' ? 'red' : 'blue';
                    gridItem.style.backgroundColor = 'gray';
                    gridItem.classList.add(cell.player === 'player' ? 'player' : 'npc');
                    gridItem.onclick = () => displayPieceInfo(cell, true);
                }
                if (cell && cell.player === 'sealed') {
                    gridItem.textContent = 'âŒ';
                    gridItem.classList.add('sealed');
                    gridItem.onclick = null;
                }
                gameBoard.appendChild(gridItem);
            });
        }

        function updateTurnIndicator() {
            turnIndicator.textContent = playerTurn ? 'è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³' : 'ç›¸æ‰‹ã®ã‚¿ãƒ¼ãƒ³';
            turnIndicator.style.color = playerTurn ? 'blue' : 'red';
        }

        function displayPieceInfo(cell, onBoard = false) {
            let infoText = '';
            if (onBoard) {
                infoText = `å ´ã®ã‚³ãƒï¼š${cell.emoji.emoji}ï¼ˆ${cell.emoji.name}ï¼‰ãƒ©ãƒ³ã‚¯${cell.emoji.rank}ã€€HPï¼š${cell.emoji.hp}/${cell.emoji.maxHp}\nåŠ¹æœï¼š${getEffectDescription(cell.emoji.effect)}`;
            } else if (cell.player === 'player') {
                infoText = `é¸æŠã—ãŸã‚³ãƒï¼š${cell.emoji.emoji}ï¼ˆ${cell.emoji.name}ï¼‰ãƒ©ãƒ³ã‚¯${cell.emoji.rank}ã€€HPï¼š${cell.emoji.hp}\nåŠ¹æœï¼š${getEffectDescription(cell.emoji.effect)}`;
            } else {
                infoText = `ç›¸æ‰‹ã®æ‰‹æœ­ï¼š${cell.emoji.emoji}ï¼ˆ${cell.emoji.name}ï¼‰ãƒ©ãƒ³ã‚¯${cell.emoji.rank}ã€€HPï¼š${cell.emoji.hp}\nåŠ¹æœï¼š${getEffectDescription(cell.emoji.effect)}`;
            }
            message.textContent = infoText;
        }

        function getEffectDescription(effect) {
            switch (effect) {
                case "heal_ally":
                    return "ç™»å ´æ™‚ã€è‡ªåˆ†ä»¥å¤–ã®å ´ã®å‘³æ–¹ä¸€ä½“ï¼ˆãƒ©ãƒ³ãƒ€ãƒ ï¼‰ã‚’1å›å¾©ã™ã‚‹ã€‚";
                case "revengeEffect":
                    return "ã“ã®ã‚³ãƒãŒHP0ä»¥ä¸‹ã«ãªã‚Šå ´ã‹ã‚‰å–ã‚Šé™¤ã‹ã‚ŒãŸæ™‚ã€å ´ã®ç›¸æ‰‹ã®ã‚³ãƒï¼‘ä½“ã«3ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã‚‹ã€‚";
                case "damage_random_enemy":
                    return "ç™»å ´æ™‚ã€å ´ã®ãƒ©ãƒ³ãƒ€ãƒ ãªç›¸æ‰‹ã®ã‚³ãƒ1ä½“ã«2ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã‚‹ã€‚";
                case "damage_self_enemy":
                    return "ç™»å ´æ™‚ã€ã“ã®ã‚³ãƒã¨å ´ã®ãƒ©ãƒ³ãƒ€ãƒ ãªç›¸æ‰‹ã®ã‚³ãƒ1ä½“ã«5ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã‚‹ã€‚ç›¸æ‰‹ã®ã‚³ãƒãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ç™ºå‹•ã—ãªã„ã€‚";
                case "swap_position":
                    return "ç™»å ´æ™‚ã€ã“ã®ã‚³ãƒã«ã‚¿ãƒ†ãƒ»ãƒ¨ã‚³ãƒ»ãƒŠãƒŠãƒ¡ã§éš£æ¥ã™ã‚‹ã‚³ãƒãŒå­˜åœ¨ã™ã‚‹å ´åˆã€ãã®ã‚³ãƒ1ã¤ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«é¸ã³ã€ã“ã®ã‚³ãƒã¨ä½ç½®ã‚’å…¥ã‚Œæ›¿ãˆã‚‹ã€‚";
                case "damage_adjacent_enemy":
                    return "ç™»å ´æ™‚ã€å‘¨å›²1ãƒã‚¹ä»¥å†…ã«ç›¸æ‰‹ã®ã‚³ãƒãŒå­˜åœ¨ã™ã‚‹å ´åˆã€ãã®ã‚³ãƒ1ä½“ï¼ˆãƒ©ãƒ³ãƒ€ãƒ ï¼‰ã«2ç‚¹ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã‚‹ã€‚";
                case "damage_column_enemy":
                    return "ç™»å ´æ™‚ã€ã“ã®ã‚³ãƒã¨åŒã˜ç¸¦åˆ—ã«ç›¸æ‰‹ã®ã‚³ãƒãŒå­˜åœ¨ã™ã‚‹å ´åˆã€ãã®ã‚³ãƒ1ä½“ï¼ˆãƒ©ãƒ³ãƒ€ãƒ ï¼‰ã«2ç‚¹ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã‚‹ã€‚";
                case "damage_row_enemy":
                    return "ç™»å ´æ™‚ã€ã“ã®ã‚³ãƒã¨åŒã˜æ¨ªåˆ—ã«ç›¸æ‰‹ã®ã‚³ãƒãŒå­˜åœ¨ã™ã‚‹å ´åˆã€ãã®ã‚³ãƒ1ä½“ï¼ˆãƒ©ãƒ³ãƒ€ãƒ ï¼‰ã«2ç‚¹ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã‚‹ã€‚";
                case "damage_heal":
                    return "ç™»å ´æ™‚ã€å‘¨å›²1ãƒã‚¹ä»¥å†…ã«ã“ã®ã‚³ãƒä»¥å¤–ã®ã‚³ãƒãŒå­˜åœ¨ã™ã‚‹å ´åˆã€ãã®ã‚³ãƒ1ä½“ï¼ˆãƒ©ãƒ³ãƒ€ãƒ ï¼‰ã«1ç‚¹ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã€ã“ã®ã‚³ãƒã®HPã‚’1å›å¾©ã™ã‚‹ã€‚";
                case "steal_hand":
                    return "ç™»å ´æ™‚ã€ç›¸æ‰‹ã®æ‰‹æœ­1æšã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«é¸ã³ã€è‡ªåˆ†ã®æ‰‹æœ­ã«ã™ã‚‹ã€‚";
                case "heal_every_turn":
                    return "ç™»å ´æ™‚ã€å‘¨å›²1ãƒã‚¹ä»¥å†…ã®ã‚³ãƒï¼ˆè‡ªèº«ã‚’å«ã‚€ï¼‰ã®HPã‚’1å›å¾©ã™ã‚‹ã€‚";
                case "add_gun":
                    return "ç™»å ´æ™‚ã€æ‰‹æœ­ã«ã€Œæ‹³éŠƒã€ãŒå­˜åœ¨ã™ã‚‹å ´åˆã€ã€Œæ‹³éŠƒã€1ä½“ã‚’ãƒ©ãƒ³ãƒ€ãƒ ãªç©ºã„ã¦ã„ã‚‹ãƒã‚¹ã«å‡ºã™ã€‚ã‚‚ã—æ‰‹æœ­ã«ã€Œæ‹³éŠƒã€ãŒå­˜åœ¨ã—ãªã„å ´åˆã€ã€Œæ‹³éŠƒã€1ä½“ã‚’æ‰‹æœ­ã«åŠ ãˆã‚‹ã€‚";
                case "damage_move_enemy":
                    return "ç™»å ´æ™‚ã€å ´ã®ãƒ©ãƒ³ãƒ€ãƒ ãªç›¸æ‰‹ã®ã‚³ãƒ1ä½“ã«2ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã‚‹ã€‚ã•ã‚‰ã«ã€ãã®ã‚³ãƒã‚’ç©ºã„ã¦ã„ã‚‹ãƒ©ãƒ³ãƒ€ãƒ ãªãƒã‚¹ã«ç§»å‹•ã•ã›ã‚‹ã€‚";
                case "damage_heal_self":
                    return "å‘¨å›²1ãƒã‚¹ä»¥å†…ã«ç›¸æ‰‹ã®ã‚³ãƒãŒå­˜åœ¨ã™ã‚‹å ´åˆã€ãã®ã‚³ãƒ1ä½“ï¼ˆãƒ©ãƒ³ãƒ€ãƒ ï¼‰ã«2ç‚¹ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã€è‡ªåˆ†ã®HPã‚’2å›å¾©ã™ã‚‹ã€‚";
                case "explode_on_death":
                    return "ã‚¿ãƒ¼ãƒ³çµ‚äº†æ™‚ã”ã¨ã«ã“ã®ã‚³ãƒã¯1ãƒ€ãƒ¡ãƒ¼ã‚¸å—ã‘ã‚‹ã€‚ã“ã®ã‚³ãƒãŒHP0ä»¥ä¸‹ã«ãªã‚Šå–ã‚Šé™¤ã‹ã‚ŒãŸå ´åˆã€ã“ã®ã‚³ãƒãŒã„ãŸãƒã‚¹ã®å‘¨å›²1ãƒã‚¹ä»¥å†…ã®ã‚³ãƒå…¨ã¦ã«4ç‚¹ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã‚‹ã€‚";
                case "damage_all_around":
                    return "ç™»å ´æ™‚ã€å‘¨å›²1ãƒã‚¹ä»¥å†…ã«ã“ã®ã‚³ãƒä»¥å¤–ã®ã‚³ãƒãŒå­˜åœ¨ã™ã‚‹å ´åˆã€ãã®ã‚³ãƒå…¨ã¦ã«1ç‚¹ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã‚‹ã€‚";
                case "heal_all_friends":
                    return "ç™»å ´æ™‚ã€ã“ã®ã‚³ãƒä»¥å¤–ã®å‘³æ–¹ã®ã‚³ãƒå…¨ã¦ã®HPã‚’1å›å¾©ã™ã‚‹ã€‚ã‚‚ã—ã‚‚ã“ã®ã‚³ãƒä»¥å¤–ã«è‡ªåˆ†ã®ã‚³ãƒãŒå­˜åœ¨ã—ãªã„å ´åˆã€ãƒ©ãƒ³ãƒ€ãƒ ãªã‚³ãƒ1ä½“ã‚’æ‰‹æœ­ã«åŠ ãˆã‚‹ã€‚";
                case "seal_random":
                    return "ç™»å ´æ™‚ã€ç©ºã„ã¦ã„ã‚‹ãƒã‚¹ä¸€ã¤ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«é¸ã³ã€æ¬¡ã®ç›¸æ‰‹ã‚¿ãƒ¼ãƒ³çµ‚äº†æ™‚ã¾ã§å°å°ã™ã‚‹ã€‚";
                case "damage_all_seal":
                    return "ç™»å ´æ™‚ã€ã“ã®ã‚³ãƒä»¥å¤–ã®å…¨ã¦ã®ã‚³ãƒã«3ç‚¹ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã‚‹ã€‚ã“ã®åŠ¹æœã§ã‚³ãƒã‚’å–ã‚Šé™¤ã„ãŸå ´åˆã€ç©ºã„ã¦ã„ã‚‹ãƒã‚¹ï¼‘ã¤ã‚’æ¬¡ã®ç›¸æ‰‹ã‚¿ãƒ¼ãƒ³çµ‚äº†æ™‚ã¾ã§å°å°ã™ã‚‹ã€‚";
                case "return_enemy_hand":
                    return "ç™»å ´æ™‚ã€å ´ã®ç›¸æ‰‹ã®ã‚³ãƒ1ä½“ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«é¸ã³ç›¸æ‰‹ã®æ‰‹æœ­ã«æˆ»ã™ã€‚";
                case "damage_adjacent_all_enemy":
                    return "ç™»å ´æ™‚ã€ã‚¿ãƒ†ãƒ»ãƒ¨ã‚³ã§éš£æ¥ã™ã‚‹ç›¸æ‰‹ã®ã‚³ãƒå…¨ã¦ã«4ç‚¹ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã‚‹ã€‚";
                case "add_random_hand_both":
                    return "ç™»å ´æ™‚ã€ãŠäº’ã„ã®æ‰‹æœ­ã«ãƒ©ãƒ³ãƒ€ãƒ ãªã‚³ãƒã‚’ä¸€ã¤åŠ ãˆã‚‹ã€‚";
                default:
                    return "";
            }
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }
        let selectedEmojiIndex = null;

        function selectEmoji(index, player) {
            if (!playerTurn || (player !== 'player' && player !== 'npc')) return;
            selectedEmojiIndex = index;
            const emoji = player === 'player' ? playerEmojis[index] : npcEmojis[index];
            displayPieceInfo({
                emoji: emoji,
                player: player
            }, false);
        }

        let isProcessingEffect = false; // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå‡¦ç†ä¸­ã‹ã©ã†ã‹ã‚’è¿½è·¡ã™ã‚‹ãƒ•ãƒ©ã‚°

        async function makeMove(index) {
            if (gameOver || isProcessingEffect) return; // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã¾ãŸã¯ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå‡¦ç†ä¸­ã¯ä½•ã‚‚ã—ãªã„

            // ã‚¿ãƒ¼ãƒ³ã‚¹ã‚­ãƒƒãƒ—ã®æ¡ä»¶ã‚’ãƒã‚§ãƒƒã‚¯
            checkSkipCondition(); // ã‚¹ã‚­ãƒƒãƒ—ã®å¯èƒ½æ€§ã‚’ãƒã‚§ãƒƒã‚¯
            if (!playerTurn) return; // ã‚¹ã‚­ãƒƒãƒ—ã•ã‚ŒãŸå ´åˆã¯é–¢æ•°ã‚’çµ‚äº†

            // ãƒã‚¹ãŒç©ºã„ã¦ã„ãªã„å ´åˆã‚„ã€ã‚³ãƒãŒé¸æŠã•ã‚Œã¦ã„ãªã„å ´åˆã¯ä½•ã‚‚ã—ãªã„
            if (board[index] !== null || selectedEmojiIndex === null) return;

            const selectedEmoji = playerEmojis[selectedEmojiIndex];
            board[index] = {
                emoji: selectedEmoji,
                player: 'player'
            };
            playerEmojis.splice(selectedEmojiIndex, 1); // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ‰‹æœ­ã‹ã‚‰é¸æŠã—ãŸã‚³ãƒã‚’å‰Šé™¤
            selectedEmojiIndex = null;
            renderHand(playerEmojis, playerHand, 'player'); // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ‰‹æœ­ã‚’å†æç”»
            renderBoard(); // ã‚²ãƒ¼ãƒ ãƒœãƒ¼ãƒ‰ã‚’å†æç”»
            updateLog(`ã‚ãªãŸã®${selectedEmoji.emoji}ãŒå ´ã«å‡ºãŸ`);

            // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå‡¦ç†ã‚’é–‹å§‹
            isProcessingEffect = true;
            await applyEffect(selectedEmoji, index, 'player'); // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®é©ç”¨ã‚’å¾…ã¤
            isProcessingEffect = false; // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå‡¦ç†ãŒå®Œäº†ã—ãŸã‚‰ãƒ•ãƒ©ã‚°ã‚’è§£é™¤

            renderBoard();
            checkWin(); // å‹æ•—ã®ãƒã‚§ãƒƒã‚¯
            if (!gameOver) {
                await endTurn(); // ã‚¿ãƒ¼ãƒ³çµ‚äº†å‡¦ç†
                playerTurn = false; // NPCã®ã‚¿ãƒ¼ãƒ³ã«åˆ‡ã‚Šæ›¿ãˆã‚‹
                updateTurnIndicator(); // ã‚¿ãƒ¼ãƒ³ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ã‚’æ›´æ–°
                if (npcEmojis.length > 0) setTimeout(npcTurn, 500); // NPCã®ã‚¿ãƒ¼ãƒ³ã‚’é–‹å§‹
            }
        }



        async function npcTurn() {
            if (gameOver || isProcessingEffect) return; // å‡¦ç†ä¸­ã§ã‚ã‚Œã°é–¢æ•°ã‚’çµ‚äº†

            await new Promise(resolve => setTimeout(resolve, 1000));

            if (npcEmojis.length === 0) {
                checkSkipCondition();
                return;
            }

            const noAvailableMove = board.every(cell => cell !== null) && sealedTiles.length > 0;
            if (noAvailableMove) {
                checkSkipCondition();
                return;
            }

            const emptyIndices = board.map((cell, index) => cell === null ? index : null).filter(index => index !== null);
            const availableIndices = emptyIndices.filter(index => !board[index] || board[index].player !== 'sealed');

            if (availableIndices.length === 0) return;

            const randomIndex = availableIndices[Math.floor(Math.random() * availableIndices.length)];
            const randomEmojiIndex = Math.floor(Math.random() * npcEmojis.length);
            const npcEmoji = npcEmojis[randomEmojiIndex];
            board[randomIndex] = {
                emoji: npcEmoji,
                player: 'npc'
            };
            npcEmojis.splice(randomEmojiIndex, 1);
            renderHand(npcEmojis, npcHand, 'npc');
            renderBoard();
            updateLog(`ç›¸æ‰‹ã®${npcEmoji.emoji}ãŒå ´ã«å‡ºãŸ`);

            isProcessingEffect = true; // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå‡¦ç†ä¸­ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹
            await applyEffect(npcEmoji, randomIndex, 'npc'); // åŠ¹æœé©ç”¨ãŒå®Œäº†ã™ã‚‹ã®ã‚’å¾…ã¤
            isProcessingEffect = false; // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå‡¦ç†ãŒçµ‚ã‚ã£ãŸã‚‰ãƒ•ãƒ©ã‚°ã‚’è§£é™¤

            renderBoard();
            checkWin();
            if (!gameOver) {
                // ã‚¿ãƒ¼ãƒ³åˆ‡ã‚Šæ›¿ãˆå‡¦ç†
                await endTurn(); // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå‡¦ç†ãŒã‚ã‚‹å ´åˆã¯å¾…æ©Ÿ
                playerTurn = true; // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¿ãƒ¼ãƒ³ã¸åˆ‡ã‚Šæ›¿ãˆ
                updateTurnIndicator();
            }
        }


        async function npcTurn() {
            if (gameOver || isProcessingEffect) return; // å‡¦ç†ä¸­ã§ã‚ã‚Œã°é–¢æ•°ã‚’çµ‚äº†

            await new Promise(resolve => setTimeout(resolve, 1000));

            if (npcEmojis.length === 0) {
                checkSkipCondition();
                return;
            }

            const noAvailableMove = board.every(cell => cell !== null) && sealedTiles.length > 0;
            if (noAvailableMove) {
                checkSkipCondition();
                return;
            }

            const emptyIndices = board.map((cell, index) => cell === null ? index : null).filter(index => index !== null);
            const availableIndices = emptyIndices.filter(index => !board[index] || board[index].player !== 'sealed');

            if (availableIndices.length === 0) return;

            // 1. NPCãŒå‹ã¦ã‚‹å ´åˆã¯å‹åˆ©ã™ã‚‹
            for (const pattern of winPatterns) {
                const [a, b, c] = pattern;
                const positions = [board[a], board[b], board[c]];
                if (positions.filter(p => p && p.player === 'npc').length === 2 && positions.filter(p => p === null).length === 1) {
                    const winIndex = pattern[positions.indexOf(null)];
                    if (!board[winIndex]) {
                        const npcEmoji = npcEmojis[Math.floor(Math.random() * npcEmojis.length)];
                        board[winIndex] = {
                            emoji: npcEmoji,
                            player: 'npc'
                        };
                        npcEmojis.splice(npcEmojis.indexOf(npcEmoji), 1);
                        renderHand(npcEmojis, npcHand, 'npc');
                        renderBoard();
                        updateLog(`ç›¸æ‰‹ã®${npcEmoji.emoji}ãŒå ´ã«å‡ºãŸ`);

                        isProcessingEffect = true; // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå‡¦ç†ä¸­ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹
                        await applyEffect(npcEmoji, winIndex, 'npc'); // åŠ¹æœé©ç”¨ãŒå®Œäº†ã™ã‚‹ã®ã‚’å¾…ã¤
                        isProcessingEffect = false; // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå‡¦ç†ãŒçµ‚ã‚ã£ãŸã‚‰ãƒ•ãƒ©ã‚°ã‚’è§£é™¤

                        renderBoard();
                        checkWin();
                        if (!gameOver) {
                            await endTurn(); // ã‚¿ãƒ¼ãƒ³ã®çµ‚äº†å‡¦ç†ã‚’å¾…æ©Ÿ
                            playerTurn = true; // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¿ãƒ¼ãƒ³ã«åˆ‡ã‚Šæ›¿ãˆã‚‹
                            updateTurnIndicator();
                        }
                        return;
                    }
                }
            }

            // 2. ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‹åˆ©ã‚’å¦¨å®³ã™ã‚‹
            for (const pattern of winPatterns) {
                const [a, b, c] = pattern;
                const positions = [board[a], board[b], board[c]];
                if (positions.filter(p => p && p.player === 'player').length === 2 && positions.filter(p => p === null).length === 1) {
                    const blockIndex = pattern[positions.indexOf(null)];
                    if (!board[blockIndex]) {
                        const npcEmoji = npcEmojis[Math.floor(Math.random() * npcEmojis.length)];
                        board[blockIndex] = {
                            emoji: npcEmoji,
                            player: 'npc'
                        };
                        npcEmojis.splice(npcEmojis.indexOf(npcEmoji), 1);
                        renderHand(npcEmojis, npcHand, 'npc');
                        renderBoard();
                        updateLog(`ç›¸æ‰‹ã®${npcEmoji.emoji}ãŒå ´ã«å‡ºãŸ`);

                        isProcessingEffect = true; // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå‡¦ç†ä¸­ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹
                        await applyEffect(npcEmoji, blockIndex, 'npc'); // åŠ¹æœé©ç”¨ãŒå®Œäº†ã™ã‚‹ã®ã‚’å¾…ã¤
                        isProcessingEffect = false; // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå‡¦ç†ãŒçµ‚ã‚ã£ãŸã‚‰ãƒ•ãƒ©ã‚°ã‚’è§£é™¤

                        renderBoard();
                        checkWin();
                        if (!gameOver) {
                            await endTurn(); // ã‚¿ãƒ¼ãƒ³ã®çµ‚äº†å‡¦ç†ã‚’å¾…æ©Ÿ
                            playerTurn = true; // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¿ãƒ¼ãƒ³ã«åˆ‡ã‚Šæ›¿ãˆã‚‹
                            updateTurnIndicator();
                        }
                        return;
                    }
                }
            }

            // 3. ãƒ©ãƒ³ãƒ€ãƒ ãªä½ç½®ã«ç½®ã
            const randomIndex = availableIndices[Math.floor(Math.random() * availableIndices.length)];
            const randomEmojiIndex = Math.floor(Math.random() * npcEmojis.length);
            const npcEmoji = npcEmojis[randomEmojiIndex];
            board[randomIndex] = {
                emoji: npcEmoji,
                player: 'npc'
            };
            npcEmojis.splice(randomEmojiIndex, 1);
            renderHand(npcEmojis, npcHand, 'npc');
            renderBoard();
            updateLog(`ç›¸æ‰‹ã®${npcEmoji.emoji}ãŒå ´ã«å‡ºãŸ`);

            isProcessingEffect = true; // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå‡¦ç†ä¸­ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹
            await applyEffect(npcEmoji, randomIndex, 'npc'); // åŠ¹æœé©ç”¨ãŒå®Œäº†ã™ã‚‹ã®ã‚’å¾…ã¤
            isProcessingEffect = false; // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå‡¦ç†ãŒçµ‚ã‚ã£ãŸã‚‰ãƒ•ãƒ©ã‚°ã‚’è§£é™¤

            renderBoard();
            checkWin();
            if (!gameOver) {
                await endTurn(); // ã‚¿ãƒ¼ãƒ³ã®çµ‚äº†å‡¦ç†ã‚’å¾…æ©Ÿ
                playerTurn = true; // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¿ãƒ¼ãƒ³ã«åˆ‡ã‚Šæ›¿ãˆã‚‹
                updateTurnIndicator();
            }
        }

        const winPatterns = [
            [0, 1, 2],
            [3, 4, 5],
            [6, 7, 8],
            [0, 3, 6],
            [1, 4, 7],
            [2, 5, 8],
            [0, 4, 8],
            [2, 4, 6]
        ];

        let skipCount = 0; // ã‚¹ã‚­ãƒƒãƒ—å›æ•°ã‚’è¿½è·¡ã™ã‚‹ãŸã‚ã®å¤‰æ•°

        function checkSkipCondition() {
            const hasNoHand = (playerTurn && playerEmojis.length === 0) || (!playerTurn && npcEmojis.length === 0);
            const isBoardFull = board.every(cell => cell !== null);
            const hasSealedTiles = board.some(cell => cell && cell.player === 'sealed');

            // ã‚¹ã‚­ãƒƒãƒ—ãŒå¿…è¦ãªæ¡ä»¶ãŒæˆç«‹ã™ã‚‹å ´åˆ
            if (hasNoHand || (isBoardFull && hasSealedTiles)) {
                skipCount++; // ã‚¹ã‚­ãƒƒãƒ—å›æ•°ã‚’ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆ

                // ã‚¹ã‚­ãƒƒãƒ—ã®ãƒ­ã‚°ã‚’æ›´æ–°
                updateLog(playerTurn ? "ã‚ãªãŸã®ã‚¿ãƒ¼ãƒ³ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã—ãŸ" : "ç›¸æ‰‹ã®ã‚¿ãƒ¼ãƒ³ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã—ãŸ");

                // ã‚¹ã‚­ãƒƒãƒ—ãŒ3å›é€£ç¶šã§ç™ºç”Ÿã—ãŸå ´åˆã¯å¼•ãåˆ†ã‘ã«ã™ã‚‹
                if (skipCount >= 3) {
                    endGameWithDraw(); // å¼•ãåˆ†ã‘å‡¦ç†ã‚’å‘¼ã³å‡ºã™
                    return; // ã“ã‚Œä»¥ä¸Šå‡¦ç†ã‚’è¡Œã‚ãªã„
                } else {
                    // ã‚¿ãƒ¼ãƒ³ã‚’çµ‚äº†ã—ã€æ¬¡ã®ã‚¿ãƒ¼ãƒ³ã«åˆ‡ã‚Šæ›¿ãˆã‚‹
                    endTurn();
                    playerTurn = !playerTurn; // ã‚¿ãƒ¼ãƒ³ã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹
                    updateTurnIndicator();
                    if (!gameOver) {
                        if (!playerTurn) {
                            setTimeout(npcTurn, 300); // NPCã®ã‚¿ãƒ¼ãƒ³ã‚’0.3ç§’å¾Œã«é–‹å§‹
                        }
                    }
                }
            } else {
                // ã‚¹ã‚­ãƒƒãƒ—ãŒç™ºç”Ÿã—ãªã‹ã£ãŸå ´åˆã€ã‚¹ã‚­ãƒƒãƒ—ã‚«ã‚¦ãƒ³ãƒˆã‚’ãƒªã‚»ãƒƒãƒˆã™ã‚‹
                skipCount = 0;
            }
        }

        function endGameWithDraw() {
            message.textContent = "å¼•ãåˆ†ã‘ï¼";
            updateLog("ã‚²ãƒ¼ãƒ çµ‚äº†ï¼šå¼•ãåˆ†ã‘");
            disableBoard();
            restartButton.style.display = 'block';
            forfeitButton.style.display = 'none';
            gameOver = true;
            resetScore(); // ã‚¹ã‚³ã‚¢ãƒªã‚»ãƒƒãƒˆãªã©ã®å¼•ãåˆ†ã‘æ™‚ã®å‡¦ç†
        }



        function checkWin() {
            let playerWins = false;
            let npcWins = false;
            for (const pattern of winPatterns) {
                const [a, b, c] = pattern;
                if (board[a] && board[a].emoji && board[b] && board[b].emoji && board[c] && board[c].emoji) {
                    if (board[a].player === board[b].player && board[a].player === board[c].player) {
                        if (board[a].player === 'player') playerWins = true;
                        if (board[a].player === 'npc') npcWins = true;
                    }
                }
            }

            if (playerWins) {
                message.textContent = "ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‹ã¡ï¼";
                updateLog("ã‚²ãƒ¼ãƒ çµ‚äº†ï¼šã‚ãªãŸã®å‹åˆ©");
                disableBoard();
                restartButton.style.display = 'block';
                forfeitButton.style.display = 'none';
                gameOver = true;
                updateScore(); // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‹åˆ©æ™‚ã«ã®ã¿ã‚¹ã‚³ã‚¢ã‚’æ›´æ–°
            } else if (npcWins) {
                message.textContent = "NPCã®å‹ã¡ï¼";
                updateLog("ã‚²ãƒ¼ãƒ çµ‚äº†ï¼šNPCã®å‹åˆ©");
                disableBoard();
                restartButton.style.display = 'block';
                forfeitButton.style.display = 'none';
                gameOver = true;
                resetScore();
            }
        }

        function disableBoard() {
            const gridItems = document.querySelectorAll('.grid-item');
            gridItems.forEach(item => item.onclick = null);
        }
        let effectQueue = []; // åŠ¹æœã‚’å¾…æ©Ÿã™ã‚‹ãŸã‚ã®ã‚­ãƒ¥ãƒ¼
        let graveyard = []; // å¢“åœ°ã‚’è¿½åŠ 
        function applyEffect(piece, index, player) {
            return new Promise((resolve) => {
                let additionalEffects = false; // é€£é–åŠ¹æœã‚’ãƒˆãƒªã‚¬ãƒ¼ã™ã‚‹ãƒ•ãƒ©ã‚°
                switch (piece.effect) {
                    case "heal_ally":
                        healAlly(index, player);
                        break;
                    case "revengeEffect":
                        if (piece.hp <= 0) {
                            revengeEffect(piece, index, player);
                            additionalEffects = true; // é€£é–åŠ¹æœã‚’ãƒˆãƒªã‚¬ãƒ¼
                        }
                        break;
                    case "damage_random_enemy":
                        damageRandomEnemy(player);
                        break;
                    case "damage_self_enemy":
                        damageSelfAndEnemy(index, player);
                        break;
                    case "swap_position":
                        swapPosition(index, player);
                        break;
                    case "damage_adjacent_enemy":
                        damageAdjacentEnemy(index, player);
                        break;
                    case "damage_column_enemy":
                        damageColumnEnemy(index, player);
                        break;
                    case "damage_row_enemy":
                        damageRowEnemy(index, player);
                        break;
                    case "damage_heal":
                        damageHeal(index, player);
                        break;
                    case "steal_hand":
                        stealHand(player);
                        break;
                    case "heal_every_turn":
                        healEveryTurn(index, player);
                        break;
                    case "add_gun":
                        addGun(index, player);
                        break;
                    case "damage_move_enemy":
                        damageMoveEnemy(index, player);
                        break;
                    case "damage_heal_self":
                        damageHealSelf(index, player);
                        break;
                    case "explode_on_death":
                        if (piece.hp <= 0) {
                            explodeOnDeath(index, player);
                            additionalEffects = true; // é€£é–åŠ¹æœã‚’ãƒˆãƒªã‚¬ãƒ¼
                        }
                        break;
                    case "damage_all_around":
                        damageAllAround(index, player);
                        break;
                    case "heal_all_friends":
                        healAllFriends(index, player);
                        break;
                    case "seal_random":
                        sealRandom(player);
                        break;
                    case "damage_all_seal":
                        damageAllSeal(index, player);
                        break;
                    case "return_enemy_hand":
                        returnEnemyHand(index, player);
                        break;
                    case "damage_adjacent_all_enemy":
                        damageAdjacentAllEnemy(index, player);
                        break;
                    case "add_random_hand_both":
                        addRandomHandBoth();
                        break;
                    default:
                        break;
                }

                // åŠ¹æœé©ç”¨å¾Œã«ç ´å£Šã•ã‚ŒãŸã‚³ãƒã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹
                checkForDeadPieces();

                // é€£é–åŠ¹æœãŒç™ºç”Ÿã—ãŸå ´åˆã€å†åº¦applyEffectã‚’å‘¼ã³å‡ºã™
                if (additionalEffects) {
                    setTimeout(() => applyEffect(piece, index, player), 500);
                }

                resolve(); // åŠ¹æœå‡¦ç†å®Œäº†æ™‚ã«Promiseã‚’è§£æ±º
            });
        }


        function processEffectQueue() {
            while (effectQueue.length > 0) {
                const effect = effectQueue.shift();
                if (effect.type === "revengeEffect") {
                    revengeEffect(effect.piece, effect.index, effect.player);
                } else if (effect.type === "explode_on_death") {
                    explodeOnDeath(effect.index, effect.player);
                }
            }
        }

        function moveToGraveyard(piece, index) {
            setTimeout(() => {
                graveyard.push(piece);
                board[index] = null; // ãƒ”ãƒ¼ã‚¹ã‚’å ´ã‹ã‚‰å–ã‚Šé™¤ã
                renderBoard(); // ãƒœãƒ¼ãƒ‰ã‚’å†æç”»
            }, 200); // 0.2ç§’ã®é…å»¶
        }


        function checkForDeadPieces() {
            let effectsToApply = [];
            // ç ´å£Šã•ã‚Œã‚‹ã¹ããƒ”ãƒ¼ã‚¹ã‚’ã€Œå¢“åœ°ã€ã«ç§»å‹•
            board.forEach((cell, i) => {
                if (cell && cell.emoji.hp <= 0) {
                    const destroyedPiece = board[i];
                    const originalEmoji = destroyedPiece.emoji.emoji;
                    destroyedPiece.emoji.emoji = 'ğŸ’¥'; // ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’è¨­å®š
                    renderBoard();

                    // åŠ¹æœã®é©ç”¨ã‚’äºˆç´„
                    switch (destroyedPiece.emoji.effect) {
                        case "revengeEffect":
                            effectsToApply.push(() => revengeEffect(destroyedPiece, destroyedPiece.originalIndex, destroyedPiece.player));
                            break;
                        case "explode_on_death":
                            effectsToApply.push(() => explodeOnDeath(destroyedPiece.originalIndex, destroyedPiece.player));
                            break;
                            // ä»–ã®åŠ¹æœã‚‚è¿½åŠ ã™ã‚‹å ´åˆã¯ã“ã“ã«æ›¸ã
                    }

                    setTimeout(() => {
                        // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®è¡¨ç¤ºãŒçµ‚ã‚ã£ãŸå¾Œã«ãƒ”ãƒ¼ã‚¹ã‚’å¢“åœ°ã«ç§»å‹•
                        moveToGraveyard(destroyedPiece, i);

                        // åŠ¹æœã®é©ç”¨ã‚’è¡Œã†
                        effectsToApply.forEach(effect => effect());
                    }, 500); // 0.5ç§’ã®é…å»¶ï¼ˆèª¿æ•´å¯èƒ½ï¼‰
                }
            });
        }


        // ãƒãƒã®åŠ¹æœ
        function revengeEffect(piece, index, player) {
            // æ—¢ã«ç™ºå‹•æ¸ˆã¿ã®ãƒ”ãƒ¼ã‚¹ã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯
            if (piece.isEffectTriggered) return;

            const enemyPieces = board.map((cell, i) => (cell && cell.player !== player && cell.player !== 'sealed') ? i : null).filter(i => i !== null);

            if (enemyPieces.length > 0) {
                const targetIndex = enemyPieces[Math.floor(Math.random() * enemyPieces.length)];
                const targetPiece = board[targetIndex];

                if (targetPiece && targetPiece.emoji) {
                    const originalEmoji = targetPiece.emoji.emoji;
                    const owner = targetPiece.player;
                    updateLog(`ğŸã®åŠ¹æœãŒç™ºå‹•ã—ãŸ`);
                    targetPiece.emoji.hp -= 3;

                    targetPiece.emoji.emoji = 'ğŸ’¥';
                    renderBoard();

                    setTimeout(() => {
                        if (targetPiece && targetPiece.emoji) {
                            targetPiece.emoji.emoji = originalEmoji;
                            renderBoard();

                            if (targetPiece.emoji.hp <= 0) {
                                moveToGraveyard(targetPiece, targetIndex);
                                updateLog(`${owner === 'player' ? 'ã‚ãªãŸã®' : 'ç›¸æ‰‹ã®'}${originalEmoji}ãŒç ´å£Šã•ã‚ŒãŸ`);

                                // ã‚‚ã—ç ´å£Šã•ã‚ŒãŸãƒ”ãƒ¼ã‚¹ãŒãƒãƒãªã‚‰ã€ãã®ãƒãƒã®åŠ¹æœã‚‚ç™ºå‹•ã•ã›ã‚‹
                                if (targetPiece.emoji.effect === 'revengeEffect' && !targetPiece.isEffectTriggered) {
                                    applyEffect(targetPiece.emoji, targetIndex, owner);
                                }

                                // ä»–ã®åŠ¹æœï¼ˆçˆ†å¼¾ãªã©ï¼‰ãŒã‚ã‚‹å ´åˆã‚‚ç™ºå‹•ã•ã›ã‚‹
                                if (targetPiece.emoji.effect === 'explode_on_death' && !targetPiece.isEffectTriggered) {
                                    applyEffect(targetPiece.emoji, targetIndex, owner);
                                }
                            }
                        }
                    }, 500);

                    updateLog(`${owner === 'player' ? 'ã‚ãªãŸã®' : 'ç›¸æ‰‹ã®'}${originalEmoji}ãŒ3ç‚¹ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ãŸ`);

                    // åŠ¹æœãŒç™ºå‹•æ¸ˆã¿ã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã™ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹
                    piece.isEffectTriggered = true;
                }
            }
        }


        // çˆ†å¼¾ã®åŠ¹æœ
        function explodeOnDeath(index, player) {
            const piece = board[index];
            if (piece && piece.emoji.name === "çˆ†å¼¾") {
                const neighbors = [];
                const row = Math.floor(index / 3);
                const col = index % 3;

                if (row > 0) neighbors.push(index - 3);
                if (row < 2) neighbors.push(index + 3);
                if (col > 0) neighbors.push(index - 1);
                if (col < 2) neighbors.push(index + 1);
                if (row > 0 && col > 0) neighbors.push(index - 4);
                if (row > 0 && col < 2) neighbors.push(index - 2);
                if (row < 2 && col > 0) neighbors.push(index + 2);
                if (row < 2 && col < 2) neighbors.push(index + 4);

                updateLog(`ğŸ’£ãŒçˆ†ç™ºã—ãŸ`);

                const damagePromises = neighbors.map(i => {
                    return new Promise((resolve) => {
                        if (i >= 0 && i < board.length && board[i]) {
                            const originalEmoji = board[i].emoji.emoji;
                            const owner = board[i].player;

                            board[i].emoji.hp -= 4;
                            board[i].emoji.emoji = 'ğŸ’¥';
                            renderBoard();

                            setTimeout(() => {
                                if (board[i]) {
                                    board[i].emoji.emoji = originalEmoji;
                                    renderBoard();
                                    if (board[i].emoji.hp <= 0) {
                                        // isEffectTriggered ãŒæœªç™ºå‹•ã§ã‚ã‚‹å ´åˆã®ã¿åŠ¹æœã‚’é©ç”¨ã™ã‚‹
                                        if (!board[i].isEffectTriggered) {
                                            moveToGraveyard(board[i], i);
                                            board[i].isEffectTriggered = true;
                                            updateLog(`${owner === 'player' ? 'ã‚ãªãŸã®' : 'ç›¸æ‰‹ã®'}${originalEmoji}ãŒç ´å£Šã•ã‚ŒãŸ`);
                                            // é€£é–åŠ¹æœã‚’ãƒã‚§ãƒƒã‚¯
                                            if (board[i].emoji.effect === 'revengeEffect' || board[i].emoji.effect === 'explode_on_death') {
                                                applyEffect(board[i].emoji, i, owner).then(resolve); // åŠ¹æœé©ç”¨å¾Œã«resolveã‚’å‘¼ã¶
                                            } else {
                                                resolve(); // åŠ¹æœãŒãªã„å ´åˆã‚‚resolveã‚’å‘¼ã¶
                                            }
                                        } else {
                                            resolve(); // æ—¢ã«åŠ¹æœãŒç™ºå‹•æ¸ˆã¿ã®å ´åˆã‚‚resolveã‚’å‘¼ã¶
                                        }
                                    } else {
                                        resolve(); // ãƒ€ãƒ¡ãƒ¼ã‚¸ã ã‘ã®å ´åˆã‚‚resolveã‚’å‘¼ã¶
                                    }
                                } else {
                                    resolve(); // ã‚»ãƒ«ãŒå­˜åœ¨ã—ãªã„å ´åˆã‚‚resolveã‚’å‘¼ã¶
                                }
                            }, 500);
                            updateLog(`${owner === 'player' ? 'ã‚ãªãŸã®' : 'ç›¸æ‰‹ã®'}${originalEmoji}ãŒ4ç‚¹ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ãŸ`);
                        } else {
                            resolve(); // ç¯„å›²å¤–ã®ã‚»ãƒ«ã‚‚resolveã‚’å‘¼ã¶
                        }
                    });
                });

                // å…¨ã¦ã®ãƒ€ãƒ¡ãƒ¼ã‚¸å‡¦ç†ãŒçµ‚ã‚ã£ãŸå¾Œã«çˆ†å¼¾ã®ã‚»ãƒ«ã‚’ã‚¯ãƒªã‚¢ã™ã‚‹
                Promise.all(damagePromises).then(() => {
                    // çˆ†å¼¾è‡ªèº«ã‚’å ´ã‹ã‚‰å–ã‚Šé™¤ã
                    board[index] = null;
                    renderBoard();
                });
            }
        }


        //ã‚¦ã‚µã‚®ã®åŠ¹æœ
        function healAlly(index, player) {
            const allies = board.map((cell, i) => cell && cell.player === player && i !== index ? i : null).filter(i => i !== null);
            if (allies.length > 0) {
                const targetIndex = allies[Math.floor(Math.random() * allies.length)];
                board[targetIndex].emoji.hp += 1;
                const originalEmoji = board[targetIndex].emoji.emoji; // å…ƒã®çµµæ–‡å­—ã‚’ä¿å­˜
                board[targetIndex].emoji.emoji = 'â¤ï¸â€ğŸ©¹';
                renderBoard();
                updateLog(`${player === 'player' ? 'ã‚ãªãŸã®' : 'ç›¸æ‰‹ã®'}${originalEmoji}ã®HPãŒ1å›å¾©ã—ãŸ`);
                setTimeout(() => {
                    board[targetIndex].emoji.emoji = originalEmoji; // å…ƒã®çµµæ–‡å­—ã«æˆ»ã™
                    renderBoard();
                }, 500);
            }
        }
        //é­”æ³•ä½¿ã„ã®åŠ¹æœ
        function damageRandomEnemy(player) {
            const enemyPieces = board
                .map((cell, index) => (cell && cell.player !== player && cell.player !== 'sealed' ? index : null))
                .filter(index => index !== null); // ä¿®æ­£ç‚¹: `cell.player !== 'sealed'` ã‚’è¿½åŠ 
            if (enemyPieces.length > 0) {
                const randomIndex = enemyPieces[Math.floor(Math.random() * enemyPieces.length)];
                const target = board[randomIndex].emoji;
                // ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã‚‹
                target.hp -= 2;
                // ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆğŸ’¥ï¼‰ã‚’è¨­å®š
                const originalEmoji = target.emoji;
                target.emoji = 'ğŸ’¥';
                renderBoard();
                setTimeout(() => {
                    target.emoji = originalEmoji; // å…ƒã®çµµæ–‡å­—ã«æˆ»ã™
                    renderBoard();
                    if (target.hp <= 0) {
                        moveToGraveyard(target, randomIndex); // ã‚³ãƒã‚’å–ã‚Šé™¤ã
                        updateLog(`${originalEmoji}ãŒç ´å£Šã•ã‚ŒãŸ`);
                    }
                }, 500); // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆè¡¨ç¤ºå¾Œã«å…ƒã®çµµæ–‡å­—ã«æˆ»ã™æ™‚é–“ã‚’è¨­å®š
                updateLog(`${player === 'player' ? 'ç›¸æ‰‹ã®' : 'ã‚ãªãŸã®'}${originalEmoji}ãŒ2ç‚¹ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ãŸ`);
            }
        }
        // æ‹³éŠƒã®åŠ¹æœ
        async function damageSelfAndEnemy(index, player) {
            // 0.5ç§’ã®é…å»¶ã‚’è¿½åŠ 
            await new Promise(resolve => setTimeout(resolve, 500));

            const enemyPieces = board
                .map((cell, index) => (cell && cell.player !== player && cell.player !== 'sealed' ? index : null))
                .filter(index => index !== null); // ä¿®æ­£ç‚¹: `cell.player !== 'sealed'` ã‚’è¿½åŠ 

            if (enemyPieces.length > 0) {
                const randomIndex = enemyPieces[Math.floor(Math.random() * enemyPieces.length)];
                const targetEnemy = board[randomIndex].emoji;
                const self = board[index].emoji;
                // è‡ªåˆ†ã¨ç›¸æ‰‹ã«ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã‚‹
                targetEnemy.hp -= 5;
                self.hp -= 5;
                // ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆğŸ’¥ï¼‰ã‚’è¨­å®š
                const originalEnemyEmoji = targetEnemy.emoji;
                const originalSelfEmoji = self.emoji;
                targetEnemy.emoji = 'ğŸ’¥';
                self.emoji = 'ğŸ’¥';
                renderBoard();
                setTimeout(() => {
                    targetEnemy.emoji = originalEnemyEmoji; // å…ƒã®çµµæ–‡å­—ã«æˆ»ã™
                    self.emoji = originalSelfEmoji; // å…ƒã®çµµæ–‡å­—ã«æˆ»ã™
                    renderBoard();
                    if (targetEnemy.hp <= 0) {
                        moveToGraveyard(targetEnemy, randomIndex); // æ­£ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’æ¸¡ã™
                        updateLog(`${originalEnemyEmoji}ãŒç ´å£Šã•ã‚ŒãŸ`);
                    }
                    if (self.hp <= 0) {
                        moveToGraveyard(self, index); // selfã‚’å–ã‚Šé™¤ã
                        updateLog(`${originalSelfEmoji}ãŒç ´å£Šã•ã‚ŒãŸ`);
                    }
                }, 500); // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆè¡¨ç¤ºå¾Œã«å…ƒã®çµµæ–‡å­—ã«æˆ»ã™æ™‚é–“ã‚’è¨­å®š
                updateLog(`${player === 'player' ? 'ç›¸æ‰‹ã®' : 'ã‚ãªãŸã®'}${originalEnemyEmoji}ãŒ5ç‚¹ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ãŸ`);
                updateLog(`${player === 'player' ? 'ã‚ãªãŸã®' : 'ç›¸æ‰‹ã®'}${originalSelfEmoji}ãŒ5ç‚¹ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ãŸ`);
            }
        }

        //çŒ¿ã®åŠ¹æœ
        function swapPosition(index, player) {
            const boardSize = 3; // 3x3ã®ãƒœãƒ¼ãƒ‰ã‚’ä»®å®š
            const adjacentIndices = [];
            // ç¾åœ¨ã®çŒ¿ã®ä½ç½®ã®è¡Œã¨åˆ—ã‚’è¨ˆç®—
            const row = Math.floor(index / boardSize);
            const col = index % boardSize;
            // ä¸Šä¸‹å·¦å³ã¨æ–œã‚ã®ä½ç½®ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦éš£æ¥ã™ã‚‹ä½ç½®ã‚’è¿½åŠ 
            if (row > 0) adjacentIndices.push(index - boardSize); // ä¸Š
            if (row < boardSize - 1) adjacentIndices.push(index + boardSize); // ä¸‹
            if (col > 0) adjacentIndices.push(index - 1); // å·¦
            if (col < boardSize - 1) adjacentIndices.push(index + 1); // å³
            if (row > 0 && col > 0) adjacentIndices.push(index - boardSize - 1); // å·¦ä¸Š
            if (row > 0 && col < boardSize - 1) adjacentIndices.push(index - boardSize + 1); // å³ä¸Š
            if (row < boardSize - 1 && col > 0) adjacentIndices.push(index + boardSize - 1); // å·¦ä¸‹
            if (row < boardSize - 1 && col < boardSize - 1) adjacentIndices.push(index + boardSize + 1); // å³ä¸‹
            // éš£æ¥ã™ã‚‹ã‚³ãƒã‚’æ¢ã—ã€å°å°ãƒã‚¹ã‚’é™¤å¤–ã™ã‚‹
            const swapCandidates = adjacentIndices.filter(i => board[i] && board[i].player !== 'sealed');
            if (swapCandidates.length > 0) {
                // ãƒ©ãƒ³ãƒ€ãƒ ã«éš£æ¥ã™ã‚‹ã‚³ãƒã‚’é¸ã¶
                const swapIndex = swapCandidates[Math.floor(Math.random() * swapCandidates.length)];
                // çŒ¿ã®ä½ç½®ã¨é¸ã°ã‚ŒãŸã‚³ãƒã®ä½ç½®ã‚’äº¤æ›ã™ã‚‹
                [board[index], board[swapIndex]] = [board[swapIndex], board[index]];
                updateLog(`${player === 'player' ? 'ã‚ãªãŸã®' : 'ç›¸æ‰‹ã®'}${board[swapIndex].emoji.emoji}ã¨çŒ¿ãŒä½ç½®ã‚’äº¤æ›ã—ãŸ`);
                renderBoard(); // ãƒœãƒ¼ãƒ‰ã‚’å†æç”»ã—ã¦å¤‰æ›´ã‚’åæ˜ 
            }
        }
        // ãƒ¯ãƒ‹ã®åŠ¹æœ
        function damageColumnEnemy(index, player) {
            const column = index % 3;
            const columnIndices = [column, column + 3, column + 6];
            const enemies = columnIndices
                .filter(i => board[i] && board[i].player !== player && board[i].player !== 'sealed'); // ä¿®æ­£ç‚¹: `board[i].player !== 'sealed'` ã‚’è¿½åŠ 

            if (enemies.length > 0) {
                const targetIndex = enemies[Math.floor(Math.random() * enemies.length)]; // æ•µã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«é¸ã¶
                const target = board[targetIndex].emoji;
                target.hp -= 2;
                // ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆğŸ’¥ï¼‰ã‚’è¨­å®š
                const originalEmoji = target.emoji;
                target.emoji = 'ğŸ’¥';
                renderBoard();
                setTimeout(() => {
                    target.emoji = originalEmoji; // å…ƒã®çµµæ–‡å­—ã«æˆ»ã™
                    renderBoard();
                    if (target.hp <= 0) {
                        moveToGraveyard(target, targetIndex); // ã‚³ãƒã‚’å–ã‚Šé™¤ã
                        updateLog(`${originalEmoji}ãŒç ´å£Šã•ã‚ŒãŸ`);
                    }
                }, 500); // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆè¡¨ç¤ºå¾Œã«å…ƒã®çµµæ–‡å­—ã«æˆ»ã™æ™‚é–“ã‚’è¨­å®š
                updateLog(`${player === 'player' ? 'ç›¸æ‰‹ã®' : 'ã‚ãªãŸã®'}${originalEmoji}ãŒ2ç‚¹ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ãŸ`);
            }
        }

        // ã‚¯ãƒã®åŠ¹æœ 
        function damageRowEnemy(index, player) {
            const row = Math.floor(index / 3);
            const rowIndices = [row * 3, row * 3 + 1, row * 3 + 2];
            const enemies = rowIndices
                .filter(i => board[i] && board[i].player !== player && board[i].player !== 'sealed'); // ä¿®æ­£ç‚¹: `board[i].player !== 'sealed'` ã‚’è¿½åŠ 

            if (enemies.length > 0) {
                const targetIndex = enemies[Math.floor(Math.random() * enemies.length)];
                const target = board[targetIndex].emoji;
                target.hp -= 2;
                // ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆğŸ’¥ï¼‰ã‚’è¨­å®š
                const originalEmoji = target.emoji;
                target.emoji = 'ğŸ’¥';
                renderBoard();
                setTimeout(() => {
                    target.emoji = originalEmoji; // å…ƒã®çµµæ–‡å­—ã«æˆ»ã™
                    renderBoard();
                    if (target.hp <= 0) {
                        moveToGraveyard(target, targetIndex); // ã‚³ãƒã‚’å–ã‚Šé™¤ã
                        updateLog(`${originalEmoji}ãŒç ´å£Šã•ã‚ŒãŸ`);
                    }
                }, 500); // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆè¡¨ç¤ºå¾Œã«å…ƒã®çµµæ–‡å­—ã«æˆ»ã™æ™‚é–“ã‚’è¨­å®š
                updateLog(`${player === 'player' ? 'ç›¸æ‰‹ã®' : 'ã‚ãªãŸã®'}${originalEmoji}ãŒ2ç‚¹ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ãŸ`);
            }
        }

        // ã‚¿ã‚³ã®åŠ¹æœ
        function damageHeal(index, player) {
            const boardSize = 3; // 3x3ã®ãƒœãƒ¼ãƒ‰ã‚’ä»®å®š
            const neighbors = [];
            // ç¾åœ¨ã®ã‚³ãƒã®ä½ç½®ã®è¡Œã¨åˆ—ã‚’è¨ˆç®—
            const row = Math.floor(index / boardSize);
            const col = index % boardSize;
            // ä¸Šä¸‹å·¦å³ã¨æ–œã‚ã®ä½ç½®ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦éš£æ¥ã—ã¦ã„ã‚‹ã‹ã‚’ç¢ºèª
            if (row > 0) neighbors.push(index - boardSize); // ä¸Š
            if (row < boardSize - 1) neighbors.push(index + boardSize); // ä¸‹
            if (col > 0) neighbors.push(index - 1); // å·¦
            if (col < boardSize - 1) neighbors.push(index + 1); // å³
            if (row > 0 && col > 0) neighbors.push(index - boardSize - 1); // å·¦ä¸Š
            if (row > 0 && col < boardSize - 1) neighbors.push(index - boardSize + 1); // å³ä¸Š
            if (row < boardSize - 1 && col > 0) neighbors.push(index + boardSize - 1); // å·¦ä¸‹
            if (row < boardSize - 1 && col < boardSize - 1) neighbors.push(index + boardSize + 1); // å³ä¸‹

            const validTargets = neighbors.filter(i => board[i] && board[i].player !== 'sealed'); // ä¿®æ­£ç‚¹: `board[i].player !== 'sealed'` ã‚’è¿½åŠ 
            if (validTargets.length > 0) {
                const targetIndex = validTargets[Math.floor(Math.random() * validTargets.length)];
                const targetEmoji = board[targetIndex].emoji;
                const playerEmoji = board[index].emoji;
                const originalTargetEmoji = targetEmoji.emoji; // å…ƒã®çµµæ–‡å­—ã‚’ä¿å­˜
                const originalPlayerEmoji = playerEmoji.emoji; // å…ƒã®çµµæ–‡å­—ã‚’ä¿å­˜
                const targetOwner = board[targetIndex].player; // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚³ãƒã®æ‰€æœ‰è€…ã‚’è¨˜éŒ²
                // ãƒ€ãƒ¡ãƒ¼ã‚¸ã¨å›å¾©ã‚’é©ç”¨
                targetEmoji.hp -= 1;
                playerEmoji.hp += 1; // ã‚¿ã‚³ã®HPã‚’å›å¾©
                // ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã¨å›å¾©ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’è¨­å®š
                targetEmoji.emoji = 'ğŸ’¥';
                playerEmoji.emoji = 'â¤ï¸â€ğŸ©¹';
                renderBoard();
                setTimeout(() => {
                    targetEmoji.emoji = originalTargetEmoji; // å…ƒã®çµµæ–‡å­—ã«æˆ»ã™
                    playerEmoji.emoji = originalPlayerEmoji; // å…ƒã®çµµæ–‡å­—ã«æˆ»ã™
                    renderBoard();
                    // HPãŒ0ä»¥ä¸‹ã«ãªã£ãŸå ´åˆã¯ãã®ã‚³ãƒã‚’å–ã‚Šé™¤ã
                    if (targetEmoji.hp <= 0) {
                        moveToGraveyard(targetEmoji, targetIndex);
                        updateLog(`${targetOwner === 'player' ? 'ã‚ãªãŸã®' : 'ç›¸æ‰‹ã®'}${originalTargetEmoji}ãŒç ´å£Šã•ã‚ŒãŸ`);
                    }
                }, 500);
                // ãƒ€ãƒ¡ãƒ¼ã‚¸ã¨å›å¾©ã®ãƒ­ã‚°ã‚’æ­£ã—ãè¡¨ç¤º
                updateLog(`${targetOwner === 'player' ? 'ã‚ãªãŸã®' : 'ç›¸æ‰‹ã®'}${originalTargetEmoji}ãŒ1ç‚¹ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ãŸ`);
                updateLog(`${player === 'player' ? 'ã‚ãªãŸã®' : 'ç›¸æ‰‹ã®'}ğŸ™ã®HPãŒ1å›å¾©ã—ãŸ`);
            }
            renderBoard(); // ãƒœãƒ¼ãƒ‰ã‚’å†æç”»ã—ã¦å¤‰æ›´ã‚’åæ˜ 
        }

        //å¿è€…ã®åŠ¹æœ
        function stealHand(player) {
            if (player === 'player' && npcEmojis.length > 0) {
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒå¿è€…ã‚’ä½¿ã£ãŸå ´åˆ
                const stolenIndex = Math.floor(Math.random() * npcEmojis.length);
                const stolenEmoji = npcEmojis[stolenIndex];
                playerEmojis.push(stolenEmoji);
                npcEmojis.splice(stolenIndex, 1);
                renderHand(playerEmojis, playerHand, 'player');
                renderHand(npcEmojis, npcHand, 'npc');
                updateLog(`ã‚ãªãŸã®æ‰‹æœ­ã«${stolenEmoji.emoji}ãŒåŠ ã‚ã£ãŸ`);
            } else if (player === 'npc' && playerEmojis.length > 0) {
                // NPCãŒå¿è€…ã‚’ä½¿ã£ãŸå ´åˆ
                const stolenIndex = Math.floor(Math.random() * playerEmojis.length);
                const stolenEmoji = playerEmojis[stolenIndex];
                npcEmojis.push(stolenEmoji);
                playerEmojis.splice(stolenIndex, 1);
                renderHand(playerEmojis, playerHand, 'player');
                renderHand(npcEmojis, npcHand, 'npc');
                updateLog(`ç›¸æ‰‹ã®æ‰‹æœ­ã«${stolenEmoji.emoji}ãŒåŠ ã‚ã£ãŸ`);
            }
        }
        //è­¦å®˜ã®åŠ¹æœ
        function addGun(index, player) {
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒè­¦å®˜ã‚’ä½¿ã£ãŸå ´åˆ
            if (player === 'player') {
                const gunIndex = playerEmojis.findIndex(emoji => emoji.name === 'æ‹³éŠƒ');
                const emptyIndices = board.map((cell, index) => cell === null ? index : null).filter(index => index !== null);
                if (gunIndex !== -1 && emptyIndices.length > 0) {
                    const gun = playerEmojis.splice(gunIndex, 1)[0];
                    const randomIndex = emptyIndices[Math.floor(Math.random() * emptyIndices.length)];
                    board[randomIndex] = {
                        emoji: gun,
                        player: player
                    };
                    renderHand(playerEmojis, playerHand, 'player');
                    renderBoard();
                    updateLog(`ã‚ãªãŸã®${gun.emoji}ãŒå ´ã«å‡ºãŸ`);
                    // Trigger gun's effect immediately after placing
                    setTimeout(() => {
                        if (checkWin()) return;
                        applyEffect(gun, randomIndex, player);
                    }, 500);
                } else if (gunIndex === -1) {
                    const newGun = {
                        emoji: "ğŸ”«",
                        name: "æ‹³éŠƒ",
                        rank: "â˜…",
                        hp: 1,
                        effect: "damage_self_enemy",
                        maxHp: 1
                    };
                    playerEmojis.push(newGun);
                    renderHand(playerEmojis, playerHand, 'player');
                    updateLog(`ã‚ãªãŸã®æ‰‹æœ­ã«ğŸ”«ãŒåŠ ã‚ã£ãŸ`);
                }
            }
            // NPCãŒè­¦å®˜ã‚’ä½¿ã£ãŸå ´åˆ
            else if (player === 'npc') {
                const gunIndex = npcEmojis.findIndex(emoji => emoji.name === 'æ‹³éŠƒ');
                const emptyIndices = board.map((cell, index) => cell === null ? index : null).filter(index => index !== null);
                if (gunIndex !== -1 && emptyIndices.length > 0) {
                    const gun = npcEmojis.splice(gunIndex, 1)[0];
                    const randomIndex = emptyIndices[Math.floor(Math.random() * emptyIndices.length)];
                    board[randomIndex] = {
                        emoji: gun,
                        player: player
                    };
                    renderHand(npcEmojis, npcHand, 'npc');
                    renderBoard();
                    updateLog(`ç›¸æ‰‹ã®${gun.emoji}ãŒå ´ã«å‡ºãŸ`);
                    // Trigger gun's effect immediately after placing
                    setTimeout(() => {
                        if (checkWin()) return;
                        applyEffect(gun, randomIndex, player);
                    }, 500);
                } else if (gunIndex === -1) {
                    const newGun = {
                        emoji: "ğŸ”«",
                        name: "æ‹³éŠƒ",
                        rank: "â˜…",
                        hp: 1,
                        effect: "damage_self_enemy",
                        maxHp: 1
                    };
                    npcEmojis.push(newGun);
                    renderHand(npcEmojis, npcHand, 'npc');
                    updateLog(`ç›¸æ‰‹ã®æ‰‹æœ­ã«ğŸ”«ãŒåŠ ã‚ã£ãŸ`);
                }
            }
        }
        // å¤©ç‹—ã®åŠ¹æœ
        function damageMoveEnemy(index, player) {
            const enemyPieces = board.map((cell, index) => (cell && cell.player !== player && cell.player !== 'sealed') ? index : null).filter(index => index !== null);
            if (enemyPieces.length > 0) {
                const randomIndex = enemyPieces[Math.floor(Math.random() * enemyPieces.length)];
                if (board[randomIndex] && board[randomIndex].emoji) { // ãƒã‚§ãƒƒã‚¯ã‚’è¿½åŠ 
                    const targetEmoji = board[randomIndex].emoji;
                    const originalEmoji = targetEmoji.emoji; // å…ƒã®çµµæ–‡å­—ã‚’ä¿å­˜
                    const targetOwner = board[randomIndex].player; // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚³ãƒã®æ‰€æœ‰è€…ã‚’è¨˜éŒ²
                    // ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã‚‹
                    targetEmoji.hp -= 2;
                    targetEmoji.emoji = 'ğŸ’¥'; // ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’è¨­å®š
                    renderBoard();
                    setTimeout(() => {
                        if (board[randomIndex] && board[randomIndex].emoji) { // ãƒã‚§ãƒƒã‚¯ã‚’è¿½åŠ 
                            targetEmoji.emoji = originalEmoji; // å…ƒã®çµµæ–‡å­—ã«æˆ»ã™
                            renderBoard();
                            if (targetEmoji.hp > 0) {
                                const emptyIndices = board.map((cell, index) => cell === null ? index : null).filter(index => index !== null);
                                if (emptyIndices.length > 0) {
                                    const moveToIndex = emptyIndices[Math.floor(Math.random() * emptyIndices.length)];
                                    board[moveToIndex] = board[randomIndex];
                                    board[randomIndex] = null;
                                    updateLog(`${targetOwner === 'player' ? 'ã‚ãªãŸã®' : 'ç›¸æ‰‹ã®'}${board[moveToIndex].emoji.emoji}ãŒç§»å‹•ã—ãŸ`);
                                    renderBoard();
                                }
                            } else {
                                moveToGraveyard(targetEmoji, randomIndex);
                                updateLog(`${targetOwner === 'player' ? 'ã‚ãªãŸã®' : 'ç›¸æ‰‹ã®'}${originalEmoji}ãŒç ´å£Šã•ã‚ŒãŸ`);
                            }
                        }
                    }, 500);
                    updateLog(`${targetOwner === 'player' ? 'ã‚ãªãŸã®' : 'ç›¸æ‰‹ã®'}${originalEmoji}ãŒ2ç‚¹ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ãŸ`);
                }
            }
        }
        // å¸è¡€é¬¼ã®åŠ¹æœ
        function damageHealSelf(index, player) {
            const boardSize = 3; // 3x3ã®ãƒœãƒ¼ãƒ‰ã‚’ä»®å®š
            const neighbors = [];
            // ç¾åœ¨ã®ã‚³ãƒã®ä½ç½®ã®è¡Œã¨åˆ—ã‚’è¨ˆç®—
            const row = Math.floor(index / boardSize);
            const col = index % boardSize;
            // ä¸Šä¸‹å·¦å³ã¨æ–œã‚ã®ä½ç½®ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦éš£æ¥ã—ã¦ã„ã‚‹ã‹ã‚’ç¢ºèª
            if (row > 0) neighbors.push(index - boardSize); // ä¸Š
            if (row < boardSize - 1) neighbors.push(index + boardSize); // ä¸‹
            if (col > 0) neighbors.push(index - 1); // å·¦
            if (col < boardSize - 1) neighbors.push(index + 1); // å³
            if (row > 0 && col > 0) neighbors.push(index - boardSize - 1); // å·¦ä¸Š
            if (row > 0 && col < boardSize - 1) neighbors.push(index - boardSize + 1); // å³ä¸Š
            if (row < boardSize - 1 && col > 0) neighbors.push(index + boardSize - 1); // å·¦ä¸‹
            if (row < boardSize - 1 && col < boardSize - 1) neighbors.push(index + boardSize + 1); // å³ä¸‹

            const validTargets = neighbors.filter(i => board[i] && board[i].player !== player && board[i].player !== 'sealed'); // ä¿®æ­£ç‚¹: `board[i].player !== 'sealed'` ã‚’è¿½åŠ 
            if (validTargets.length > 0) {
                const targetIndex = validTargets[Math.floor(Math.random() * validTargets.length)];
                const targetEmoji = board[targetIndex].emoji;
                const playerEmoji = board[index].emoji;
                // ãƒ€ãƒ¡ãƒ¼ã‚¸ã¨å›å¾©ã‚’é©ç”¨
                targetEmoji.hp -= 2;
                playerEmoji.hp += 2; // å¸è¡€é¬¼ã®HPã‚’å›å¾©
                // ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã¨å›å¾©ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’è¨­å®š
                const originalTargetEmoji = targetEmoji.emoji; // å…ƒã®çµµæ–‡å­—ã‚’ä¿å­˜
                const originalPlayerEmoji = playerEmoji.emoji; // å…ƒã®çµµæ–‡å­—ã‚’ä¿å­˜
                targetEmoji.emoji = 'ğŸ’¥';
                playerEmoji.emoji = 'â¤ï¸â€ğŸ©¹';
                renderBoard();
                setTimeout(() => {
                    targetEmoji.emoji = originalTargetEmoji; // å…ƒã®çµµæ–‡å­—ã«æˆ»ã™
                    playerEmoji.emoji = originalPlayerEmoji; // å…ƒã®çµµæ–‡å­—ã«æˆ»ã™
                    renderBoard();
                    if (targetEmoji.hp <= 0) {
                        moveToGraveyard(targetEmoji, targetIndex); // ç ´å£Šã•ã‚ŒãŸã‚³ãƒã‚’å–ã‚Šé™¤ã
                        updateLog(`${originalTargetEmoji}ãŒç ´å£Šã•ã‚ŒãŸ`);
                    }
                }, 500);
                updateLog(`${player === 'player' ? 'ç›¸æ‰‹ã®' : 'ã‚ãªãŸã®'}${originalTargetEmoji}ãŒ2ç‚¹ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ãŸ`);
                updateLog(`${player === 'player' ? 'ã‚ãªãŸã®' : 'ç›¸æ‰‹ã®'}å¸è¡€é¬¼ã®HPãŒ2å›å¾©ã—ãŸ`);
            }
        }


        // ãƒ©ã‚¤ã‚ªãƒ³ã®åŠ¹æœ
        function damageAllAround(index, player) {
            const boardSize = 3; // 3x3ã®ãƒœãƒ¼ãƒ‰ã‚’ä»®å®š
            const neighbors = [];
            // ç¾åœ¨ã®ã‚³ãƒã®ä½ç½®ã®è¡Œã¨åˆ—ã‚’è¨ˆç®—
            const row = Math.floor(index / boardSize);
            const col = index % boardSize;
            // ä¸Šä¸‹å·¦å³ã¨æ–œã‚ã®ä½ç½®ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦éš£æ¥ã—ã¦ã„ã‚‹ã‹ã‚’ç¢ºèª
            if (row > 0) neighbors.push(index - boardSize); // ä¸Š
            if (row < boardSize - 1) neighbors.push(index + boardSize); // ä¸‹
            if (col > 0) neighbors.push(index - 1); // å·¦
            if (col < boardSize - 1) neighbors.push(index + 1); // å³
            if (row > 0 && col > 0) neighbors.push(index - boardSize - 1); // å·¦ä¸Š
            if (row > 0 && col < boardSize - 1) neighbors.push(index - boardSize + 1); // å³ä¸Š
            if (row < boardSize - 1 && col > 0) neighbors.push(index + boardSize - 1); // å·¦ä¸‹
            if (row < boardSize - 1 && col < boardSize - 1) neighbors.push(index + boardSize + 1); // å³ä¸‹
            neighbors.forEach(i => {
                if (board[i]) {
                    const targetEmoji = board[i].emoji;
                    const originalEmoji = targetEmoji.emoji; // å…ƒã®çµµæ–‡å­—ã‚’ä¿å­˜
                    const owner = board[i].player; // ã‚³ãƒã®æ‰€æœ‰è€…ã‚’è¨˜éŒ²
                    // ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã‚‹
                    targetEmoji.hp -= 1;
                    targetEmoji.emoji = 'ğŸ’¥'; // ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’è¨­å®š
                    renderBoard();
                    setTimeout(() => {
                        if (board[i]) { // ã‚³ãƒãŒã¾ã å­˜åœ¨ã™ã‚‹å ´åˆã®ã¿å‡¦ç†ã‚’ç¶šè¡Œ
                            targetEmoji.emoji = originalEmoji; // å…ƒã®çµµæ–‡å­—ã«æˆ»ã™
                            renderBoard();
                            // HPãŒ0ä»¥ä¸‹ã«ãªã£ãŸå ´åˆã¯ãã®ã‚³ãƒã‚’å–ã‚Šé™¤ã
                            if (targetEmoji.hp <= 0) {
                                moveToGraveyard(targetEmoji, i);
                                updateLog(`${owner === 'player' ? 'ã‚ãªãŸã®' : 'ç›¸æ‰‹ã®'}${originalEmoji}ãŒç ´å£Šã•ã‚ŒãŸ`);
                            }
                        }
                    }, 500); // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆè¡¨ç¤ºå¾Œã«å…ƒã®çµµæ–‡å­—ã«æˆ»ã™æ™‚é–“ã‚’è¨­å®š
                    // ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ãŸãƒ­ã‚°ã‚’æ­£ã—ãè¡¨ç¤º
                    updateLog(`${owner === 'player' ? 'ã‚ãªãŸã®' : 'ç›¸æ‰‹ã®'}${originalEmoji}ãŒ1ç‚¹ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ãŸ`);
                }
            });
        }
        //ãƒ¦ãƒ‹ã‚³ãƒ¼ãƒ³ã®åŠ¹æœ
        function healAllFriends(index, player) {
            const allies = board.map((cell, i) => cell && cell.player === player && i !== index ? i : null).filter(i => i !== null);
            if (allies.length > 0) {
                allies.forEach(i => {
                    if (board[i] && board[i].emoji) {
                        const originalEmoji = board[i].emoji.emoji; // å…ƒã®çµµæ–‡å­—ã‚’ä¿å­˜
                        board[i].emoji.hp += 1;
                        board[i].emoji.emoji = 'â¤ï¸â€ğŸ©¹';
                        renderBoard();
                        updateLog(`${player === 'player' ? 'ã‚ãªãŸã®' : 'ç›¸æ‰‹ã®'}${originalEmoji}ã®HPãŒ1å›å¾©ã—ãŸ`);

                        // å›å¾©ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãŒå®Œäº†ã™ã‚‹ã¾ã§å¾…ã£ã¦ã‹ã‚‰å‡¦ç†ã‚’ç¶šè¡Œ
                        setTimeout(() => {
                            if (board[i] && board[i].emoji) {
                                board[i].emoji.emoji = originalEmoji; // å…ƒã®çµµæ–‡å­—ã«æˆ»ã™
                                renderBoard();
                            }
                        }, 500);
                    }
                });
            } else {
                const randomEmoji = emojis[Math.floor(Math.random() * emojis.length)];
                if (player === 'player') {
                    playerEmojis.push(randomEmoji);
                    renderHand(playerEmojis, playerHand, 'player');
                    updateLog(`ã‚ãªãŸã®æ‰‹æœ­ã«${randomEmoji.emoji}ãŒåŠ ã‚ã£ãŸ`);
                } else {
                    npcEmojis.push(randomEmoji);
                    renderHand(npcEmojis, npcHand, 'npc');
                    updateLog(`ç›¸æ‰‹ã®æ‰‹æœ­ã«${randomEmoji.emoji}ãŒåŠ ã‚ã£ãŸ`);
                }
            }
        }
        //æ‚ªé­”ã®åŠ¹æœ
        function sealRandom(player) {
            const emptyIndices = board.map((cell, index) => cell === null ? index : null).filter(index => index !== null);
            if (emptyIndices.length > 0) {
                const randomIndex = emptyIndices[Math.floor(Math.random() * emptyIndices.length)];
                // å°å°ã‚’è¨­å®šã™ã‚‹éš›ã«ã€å°å°ã‚’ç™ºå‹•ã—ãŸãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è¨˜éŒ²
                board[randomIndex] = {
                    emoji: {
                        emoji: "âŒ",
                        name: "å°å°",
                        hp: 99,
                        effect: "none"
                    },
                    player: 'sealed',
                    sealPlayer: player
                };
                sealedTiles.push(randomIndex);
                updateLog(`${player === 'player' ? 'ç›¸æ‰‹ã®ã‚¿ãƒ¼ãƒ³çµ‚äº†æ™‚ã¾ã§' : 'ã‚ãªãŸã®ã‚¿ãƒ¼ãƒ³çµ‚äº†æ™‚ã¾ã§'}ãƒã‚¹ãŒå°å°ã•ã‚ŒãŸ`);
            }
        }

        function updateSealStatus() {
            // ç¾åœ¨ã®ã‚¿ãƒ¼ãƒ³ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’åŸºã«å°å°ã‚’è§£é™¤ã™ã‚‹æ¡ä»¶ã‚’è¨­å®š
            const currentPlayer = playerTurn ? 'player' : 'npc';
            for (let i = sealedTiles.length - 1; i >= 0; i--) {
                const tileIndex = sealedTiles[i];
                if (board[tileIndex] && board[tileIndex].player === 'sealed') {
                    // å°å°ã‚’ç™ºå‹•ã—ãŸãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ç¾åœ¨ã®ã‚¿ãƒ¼ãƒ³ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’æ¯”è¼ƒã—ã€ä¸€è‡´ã—ãªã„å ´åˆã®ã¿è§£é™¤
                    if (board[tileIndex].sealPlayer === currentPlayer) {
                        board[tileIndex] = null; // å°å°è§£é™¤
                        sealedTiles.splice(i, 1); // å°å°ãƒªã‚¹ãƒˆã‹ã‚‰å‰Šé™¤
                        updateLog("å°å°ãŒè§£é™¤ã•ã‚Œã¾ã—ãŸ");
                    }

                }
            }
            renderBoard(); // å°å°çŠ¶æ…‹ã®æ›´æ–°å¾Œã«ãƒœãƒ¼ãƒ‰ã‚’å†ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
        }

        // ãƒ‰ãƒ©ã‚´ãƒ³ã®åŠ¹æœ
        function damageAllSeal(index, player) {
            let dragonEffectTriggered = false; // ãƒ‰ãƒ©ã‚´ãƒ³åŠ¹æœãƒˆãƒªã‚¬ãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆ
            const damagePromises = []; // éåŒæœŸå‡¦ç†ã‚’ç®¡ç†ã™ã‚‹ãŸã‚ã®é…åˆ—

            board.forEach((cell, i) => {
                if (i !== index && cell) {
                    const targetEmoji = cell.emoji;
                    const originalEmoji = targetEmoji.emoji; // å…ƒã®çµµæ–‡å­—ã‚’ä¿å­˜
                    const owner = cell.player; // ã‚³ãƒã®æ‰€æœ‰è€…ã‚’è¨˜éŒ²

                    // ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã‚‹
                    targetEmoji.hp -= 3;
                    targetEmoji.emoji = 'ğŸ’¥'; // ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’è¨­å®š
                    renderBoard();
                    updateLog(`${owner === 'player' ? 'ã‚ãªãŸã®' : 'ç›¸æ‰‹ã®'}${originalEmoji}ãŒ3ç‚¹ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ãŸ`);

                    // éåŒæœŸå‡¦ç†ã¨ã—ã¦ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’æˆ»ã™
                    const damagePromise = new Promise((resolve) => {
                        setTimeout(() => {
                            if (targetEmoji.hp <= 0) {
                                moveToGraveyard(targetEmoji, i); // HPãŒ0ä»¥ä¸‹ãªã‚‰ã‚³ãƒã‚’å‰Šé™¤
                                dragonEffectTriggered = true;
                                updateLog(`${owner === 'player' ? 'ã‚ãªãŸã®' : 'ç›¸æ‰‹ã®'}${originalEmoji}ãŒç ´å£Šã•ã‚ŒãŸ`);
                            } else {
                                targetEmoji.emoji = originalEmoji; // å…ƒã®çµµæ–‡å­—ã«æˆ»ã™
                                renderBoard();
                            }
                            resolve();
                        }, 500); // ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’è¡¨ç¤ºã™ã‚‹æ™‚é–“
                    });

                    damagePromises.push(damagePromise);
                }
            });

            // ã™ã¹ã¦ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãŒå®Œäº†ã—ãŸå¾Œã«å°å°ã‚’é©ç”¨
            Promise.all(damagePromises).then(() => {
                if (dragonEffectTriggered) { // ãƒ‰ãƒ©ã‚´ãƒ³åŠ¹æœãŒãƒˆãƒªã‚¬ãƒ¼ã•ã‚ŒãŸå ´åˆã«ã®ã¿å°å°ã‚’é©ç”¨
                    const emptyIndices = board.map((cell, index) => cell === null ? index : null).filter(index => index !== null);
                    if (emptyIndices.length > 0) {
                        const randomIndex = emptyIndices[Math.floor(Math.random() * emptyIndices.length)];
                        board[randomIndex] = {
                            emoji: {
                                emoji: "âŒ",
                                name: "å°å°",
                                hp: 99,
                                effect: "none"
                            },
                            player: 'sealed',
                            sealPlayer: player
                        };
                        sealedTiles.push(randomIndex);
                        updateLog(`${player === 'player' ? 'ç›¸æ‰‹ã®ã‚¿ãƒ¼ãƒ³çµ‚äº†æ™‚ã¾ã§' : 'ã‚ãªãŸã®ã‚¿ãƒ¼ãƒ³çµ‚äº†æ™‚ã¾ã§'}ãƒã‚¹ãŒå°å°ã•ã‚ŒãŸ`);
                        renderBoard(); // å°å°ã®å¾Œã§ãƒœãƒ¼ãƒ‰ã‚’å†æç”»
                    }
                }
            });
        }

        //å®‡å®™äººã®åŠ¹æœ
        function returnEnemyHand(index, player) {
            const enemyPieces = board.map((cell, i) => (cell && cell.player !== player && cell.player !== 'sealed') ? i : null).filter(i => i !== null);
            if (enemyPieces.length > 0) {
                const targetIndex = enemyPieces[Math.floor(Math.random() * enemyPieces.length)];
                const targetEmoji = deepCopy(board[targetIndex].emoji); // æ·±ã„ã‚³ãƒ”ãƒ¼ã‚’ä½œæˆ

                // ã‚³ãƒã®HPã‚’æœ€å¤§å€¤ã«ãƒªã‚»ãƒƒãƒˆ
                targetEmoji.hp = targetEmoji.maxHp;

                // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚„è¡¨ç¤ºã‚’åˆæœŸçŠ¶æ…‹ã«æˆ»ã™
                targetEmoji.emoji = emojis.find(e => e.name === targetEmoji.name).emoji;

                if (player === 'player') {
                    npcEmojis.push(targetEmoji);
                    renderHand(npcEmojis, npcHand, 'npc');
                    updateLog(`ç›¸æ‰‹ã®æ‰‹æœ­ã«${targetEmoji.emoji}ãŒåŠ ã‚ã£ãŸ`);
                } else if (player === 'npc') {
                    playerEmojis.push(targetEmoji);
                    renderHand(playerEmojis, playerHand, 'player');
                    updateLog(`ã‚ãªãŸã®æ‰‹æœ­ã«${targetEmoji.emoji}ãŒåŠ ã‚ã£ãŸ`);
                }
                board[targetIndex] = null;
                renderBoard();
            }
        }


        // é¬¼ã®åŠ¹æœ
        function damageAdjacentAllEnemy(index, player) {
            const boardSize = 3; // 3x3ã®ãƒœãƒ¼ãƒ‰ã‚’ä»®å®š
            const neighbors = [];
            // ç¾åœ¨ã®ã‚³ãƒã®ä½ç½®ã®è¡Œã¨åˆ—ã‚’è¨ˆç®—
            const row = Math.floor(index / boardSize);
            const col = index % boardSize;
            // ä¸Šä¸‹å·¦å³ã®ä½ç½®ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦éš£æ¥ã™ã‚‹ä½ç½®ã‚’è¿½åŠ 
            if (row > 0) neighbors.push(index - boardSize); // ä¸Š
            if (row < boardSize - 1) neighbors.push(index + boardSize); // ä¸‹
            if (col > 0) neighbors.push(index - 1); // å·¦
            if (col < boardSize - 1) neighbors.push(index + 1); // å³
            // ä¸Šä¸‹å·¦å³ã®éš£æ¥ã™ã‚‹ã‚³ãƒã‚’æ¢ã—ã€ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã‚‹
            const validTargets = neighbors.filter(i => board[i] && board[i].player !== player);
            validTargets.forEach(i => {
                const targetEmoji = board[i].emoji;
                const originalEmoji = targetEmoji.emoji; // å…ƒã®çµµæ–‡å­—ã‚’ä¿å­˜
                // ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã‚‹
                targetEmoji.hp -= 4;
                targetEmoji.emoji = 'ğŸ’¥'; // ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’è¨­å®š
                renderBoard();
                setTimeout(() => {
                    targetEmoji.emoji = originalEmoji; // å…ƒã®çµµæ–‡å­—ã«æˆ»ã™
                    renderBoard();
                    if (targetEmoji.hp <= 0) {
                        moveToGraveyard(targetEmoji, i); // ç ´å£Šã•ã‚ŒãŸã‚³ãƒã‚’å–ã‚Šé™¤ã
                        updateLog(`${originalEmoji}ãŒç ´å£Šã•ã‚ŒãŸ`);
                    }
                }, 500); // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆè¡¨ç¤ºå¾Œã«å…ƒã®çµµæ–‡å­—ã«æˆ»ã™æ™‚é–“ã‚’è¨­å®š
                updateLog(`${player === 'player' ? 'ç›¸æ‰‹ã®' : 'ã‚ãªãŸã®'}${originalEmoji}ãŒ4ç‚¹ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ãŸ`);
            });
        }
        // å¤©ä½¿ã®åŠ¹æœ
        function addRandomHandBoth() {
            const randomEmojiForPlayer = {
                ...emojis[Math.floor(Math.random() * emojis.length)]
            };
            const randomEmojiForNPC = {
                ...emojis[Math.floor(Math.random() * emojis.length)]
            };
            playerEmojis.push(randomEmojiForPlayer);
            npcEmojis.push(randomEmojiForNPC);
            renderHand(playerEmojis, playerHand, 'player');
            renderHand(npcEmojis, npcHand, 'npc');
            updateLog(`ã‚ãªãŸã®æ‰‹æœ­ã«${randomEmojiForPlayer.emoji}ãŒåŠ ã‚ã£ãŸ`);
            updateLog(`ç›¸æ‰‹ã®æ‰‹æœ­ã«${randomEmojiForNPC.emoji}ãŒåŠ ã‚ã£ãŸ`);
        }

        function updateLog(entry) {
            logEntries.push(entry);
            if (logContainer.style.display !== 'none') {
                const logText = logEntries.map(log => `<p>${log}</p>`).join('');
                logContainer.innerHTML = logText;
            }
        }

        function toggleLog() {
            logContainer.style.display = logContainer.style.display === 'none' ? 'block' : 'none';
            if (logContainer.style.display === 'block') {
                const logText = logEntries.map(log => `<p>${log}</p>`).join('');
                logContainer.innerHTML = logText;
            }
        }

        function resetGame() {
            playerTurn = true;
            gameOver = false;
            logEntries = [];
            board.fill(null);
            playerEmojis = [];
            npcEmojis = [];
            document.getElementById('rule-container').style.display = 'block';
            document.getElementById('npc-hand-container').style.display = 'none';
            document.getElementById('player-hand-container').style.display = 'none';
            gameBoard.style.display = 'none';
            message.style.display = 'none';
            turnIndicator.style.display = 'none';
            restartButton.style.display = 'none';
            levelSelect.style.display = 'block';
            forfeitButton.style.display = 'none';
            logButton.style.display = 'none'; // ãƒªã‚»ãƒƒãƒˆæ™‚ã«ãƒ†ã‚­ã‚¹ãƒˆãƒ­ã‚°ãƒœã‚¿ãƒ³ã‚’éè¡¨ç¤º
            logContainer.style.display = 'none';
            logContainer.innerHTML = '';
            // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ã‚¯ãƒªã‚¢
            message.textContent = '';
        }

        function forfeitGame() {
            updateLog("ã‚ãªãŸã¯é™å‚ã—ãŸ");
            disableBoard();
            message.textContent = "é™å‚ã—ã¾ã—ãŸ";
            restartButton.style.display = 'block';
            forfeitButton.style.display = 'none';
            resetScore();
        }

        function updateScore() {
            score += level * 10;
            winStreak++;
            winStreakScore.innerHTML = `<br>é€£å‹æ•°: ${winStreak} ã‚¹ã‚³ã‚¢: ${score}ç‚¹`;
        }

        function resetScore() {
            winStreak = 0;
            score = 0;
            winStreakScore.innerHTML = `<br>é€£å‹æ•°: ${winStreak} ã‚¹ã‚³ã‚¢: ${score}ç‚¹`;
        }


        function endTurn() {
            if (isProcessingEffect) return; // å‡¦ç†ä¸­ã§ã‚ã‚Œã°é–¢æ•°ã‚’çµ‚äº†

            setTimeout(() => {
                updateSealStatus();

                let damagePromises = [];

                board.forEach((cell, index) => {
                    if (cell && cell.emoji.name === "çˆ†å¼¾") {
                        const damagePromise = new Promise((resolve) => {
                            const originalEmoji = cell.emoji.emoji;
                            cell.emoji.emoji = 'ğŸ’¥';
                            renderBoard();

                            setTimeout(() => {
                                cell.emoji.emoji = originalEmoji;
                                renderBoard();

                                cell.emoji.hp -= 1;
                                if (cell.emoji.hp <= 0) {
                                    explodeOnDeath(index, cell.player).then(resolve);
                                } else {
                                    resolve();
                                }
                            }, 500);
                        });

                        damagePromises.push(damagePromise);
                    }
                });

                Promise.all(damagePromises).then(() => {
                    checkWin();
                    checkDraw();
                    renderBoard();
                });
            }, 1000);
        }

        function checkDraw() {
            const hasSealedTiles = board.some(cell => cell && cell.player === 'sealed');
            if (!hasSealedTiles && (board.every(cell => cell !== null) || (playerEmojis.length === 0 && npcEmojis.length === 0))) {
                message.textContent = "å¼•ãåˆ†ã‘ï¼";
                updateLog("ã‚²ãƒ¼ãƒ çµ‚äº†ï¼šå¼•ãåˆ†ã‘");
                disableBoard();
                restartButton.style.display = 'block';
                forfeitButton.style.display = 'none';
                gameOver = true;
                resetScore();
            }
        }

    </script>
</body>

</html>
